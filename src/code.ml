(*
 * Parser Generator Generator v. 1.0
 * by Jedidiah R. McClurg
 * Northwestern University
 * 
 * code.ml
 *
 * Contains functionality for translating the AST into
 * OCaml code compatible with Yacc/Lex.
 *)

open Ast;;
open Utils;;
open Flags;;

let this_var = "s";;
let this_var2 = "t";;

module SubpatternHashtbl = Hashtbl.Make(struct
                                           type t = subpattern
                                           let equal a b = (reloc_subpattern a) = (reloc_subpattern b)
                                           let hash s = Hashtbl.hash (reloc_subpattern s)
                                        end);;

let output_warning_msg (f : out_channel) (s1 : string) (s4 : string) (s2 : string) (s3 : string) : unit =
   output_string f (s1^
   s4^" THIS IS AN AUTO-GENERATED FILE PRODUCED BY PGG!\n"^
   s2^" DO NOT EDIT THIS FILE, since any changes will be\n"^
   s2^" lost when the build is reset via \"make clean\".\n"^
   s2^" This file is based on a user-specified EBNF\n"^
   s2^" grammar, which can be edited as desired.\n"^
   s3)
;;

let get_assoc_str (a : assoc option) (pr : int option) : ((string*int) option) =
   match (a,pr) with
   | (Some(LeftAssoc(p)),None) -> Some("left",!default_prec)
   | (Some(LeftAssoc(p)),Some(i)) -> Some("left",i)
   | (Some(RightAssoc(p)),None) -> Some("right",!default_prec)
   | (Some(RightAssoc(p)),Some(i)) -> Some("right",i)
   | (Some(UnaryAssoc(p)),None) -> Some("nonassoc",!default_prec)
   | (Some(UnaryAssoc(p)),Some(i)) -> Some("nonassoc",i)
   | (None,Some(i)) -> Some(!default_assoc,i)
   | _ -> None
;;

let create_file filename =
  (* TODO - only in verbose mode! *)
  print_string ("Creating "^filename^"... ");
  flush stdout;
  open_out filename
;;

let rec flatten_grammar g = 
  match g with
  | Grammar(p,c1,c2,px,pl) ->
    let pl2 = List.fold_right (fun pr l -> (flatten_production pr)@l) (px::pl) [] in
    Grammar(p,c1,c2,List.hd pl2,List.tl pl2)
and flatten_production p = 
  match p with
  | Production(p,s,px,plx) -> let pl = px::plx in let (npl,nl) =
    List.fold_right (fun p (pl2,l) -> let (p2,e) = flatten_pattern s p in (p2::pl2,e@l)) pl ([],[]) in
    Production(p,s,List.hd npl,List.tl npl)::nl
and flatten_pattern prefix p = 
  match p with
  | Pattern(p,slx,label,eof,c,i,asc) -> let sl = slx in let (nsl,nl,_,_) =
    let len = List.length sl in
    List.fold_right (fun s (sl2,l,n,flag) ->
       (* NOTE - pull out range patterns *)
       (* NOTE - pull out *,+,?-modified stuff *)
       let new_pref = (prefix^"_"^(string_of_int n)) in
       match s with
       | RecursiveSubpattern(rp,ra1,ra2,ro) ->
          if flag then (s::sl2, l, n-1, false)
          else ((SimpleSubpattern(rp,IdentAtom(rp,new_pref),Options(rp,None,None,None,None,None,None,None)))::sl2,
          [Production(rp,new_pref,Pattern(rp,[s],None,false,Code(rp,""),None,None),[])]@l, n-1, false)
       | SimpleSubpattern(rp,IdentAtom(rp2,name),Options(rp3,Some(o),o1,o2,typo,o5,o6,o7)) ->
          let the_typename = (get_production_type name) in
          let (nm,e,tp) = (match o with
          | StarOp(_) ->
             let nm = (new_pref^"_list") in
             (nm,[Production(rp,nm,Pattern(rp,[],Some(EmptyType(rp)),false,Code(rp," [] "),None,None),
                                  [Pattern(rp,[s;
                                  SimpleSubpattern(rp,IdentAtom(rp,nm),Options(rp,None,None,None,None,None,None,None))],
                                  Some(EmptyType(rp)),false,Code(rp," $1::$2 "),None,None)])],
              (the_typename^" list"))
          | PlusOp(_) ->
             let nm = (new_pref^"_nlist") in
             (nm,[Production(rp,nm,Pattern(rp,[s],Some(EmptyType(rp)),false,(Code(rp," ($1,[]) ")),None,None),
                                  [Pattern(rp,[s;
                                  SimpleSubpattern(rp,IdentAtom(rp,nm),Options(rp,None,None,None,None,None,None,None))],
                                  Some(EmptyType(rp)),false,(Code(rp," let (h,l) = $2 in ($1,h::l) ")),None,None)])],
              ("("^the_typename^" * "^the_typename^" list)"))
          | QuestionOp(_) -> ((new_pref^"_opt"),[],"")
          ) in
          let use_type = (match typo with
          | None -> Some(Type(rp3,tp))
          | _ -> typo) in
          ((SimpleSubpattern(rp,IdentAtom(rp2,nm),Options(rp3,None,o1,o2,use_type,o5,o6,o7)))::sl2, e@l, n-1, false)
       | _ ->
          let (s2,e) = flatten_subpattern new_pref s in (s2::sl2,e@l,n-1,false)
    ) sl ([],[],len,true) in
    (Pattern(p,nsl,label,eof,c,i,asc),nl)
and flatten_subpattern prefix s = 
  if (is_subpattern_flat s) then (s,[])
  else
  match s with
  | SimpleSubpattern(p,a,o)    -> let (a2,nl) = flatten_atom prefix a in (SimpleSubpattern(p,a2,o),nl)
  | RecursiveSubpattern(p,a1,a2,o) -> (s,[])
and flatten_atom prefix a = 
  match a with
  | ChoiceAtom(p,spx,splx) ->
    let spl = spx::splx in
    let (nspl,nl,_) =
    (* here's where we expand things *)
    List.fold_right (fun sp (spl2,l,n) ->
      let (sp2,e) = flatten_subpatterns (prefix^"_"^(string_of_int n)) sp in (sp2::spl2,e@l,n-1)
    ) spl ([],[],List.length spl) in
    if (List.length spl) = 1 then (a,[]) else
    let temp = List.map (fun (Subpatterns(pa,x,l)) -> Pattern(pa,(x::l),None,false,Code(pa,""),None,None)) nspl (* TODO *) in
    (IdentAtom(p,prefix),Production(p,prefix,List.hd temp,List.tl temp)::nl)
  | _                -> (a,[])
and flatten_subpatterns prefix sp = 
  match sp with
  | Subpatterns(p,sx,sl) -> let (nsl,nl) =
    List.fold_right (fun s (sl2,l) -> let (s2,e) = flatten_subpattern prefix s in (s2::sl2,e@l)) (sx::sl) ([],[]) in
    (Subpatterns(p,List.hd nsl,List.tl nsl),nl)
;;

let rec get_terminals_grammar (g : grammar)
                              (h : (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) : unit =
   match g with
   | Grammar(_,_,_,pr,prl) ->
      List.iter (fun pr ->
         get_terminals_production pr h
      ) (pr::prl)

and get_terminals_production (pr : production)
                             (h : (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) : unit =
   match pr with
   | Production(_,name,pa,pal) ->
      let b = ((List.length pal) = 0) in
      let _ = List.fold_left (fun i pa ->
         get_terminals_pattern pa (if b then name else (name^"_"^(string_of_int i))) h;
         i+1
      ) 1 (pa::pal) in ()

and get_terminals_pattern (pa : pattern) (s : string)
                          (h : (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) : unit =
   match pa with
   | Pattern(ps,spl,t,_,_,i,asc) -> 
      let name = (to_token_case (match t with
      | Some(Type(_,s)) -> s
      | _ -> s)) in
      let x = get_assoc_str asc i in
      (match x with
      | None -> ()
      | _ -> SubpatternHashtbl.replace h
                (SimpleSubpattern(NoPos,IdentAtom(NoPos,name),Options(NoPos,None,None,None,None,None,None,None)))
                ((name^"_0"),x,None,ps)); (* TODO - does this work? *)
      let b = ((List.length spl) = 1) in
      let _ = List.fold_left (fun n sp ->
         get_terminals_subpattern sp (name^(if b then "" else ("_"^(string_of_int n)))) h n;
      ) 1 spl in ()

and get_terminals_subpattern (sp : subpattern) (s : string)
                             (h : (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) (n : int) : int =
   match sp with
   | SimpleSubpattern(_,IdentAtom(_,_),Options(ps,_,prec,a,_,_,_,_)) ->
      let x = (get_assoc_str a prec) in
      (match x with
      | Some(_) -> die_error ps "cannot set options for non-terminal" (* TODO - this should never happen (done in parser) *)
      | _ -> ());
      n+1
   | SimpleSubpattern(_,_,Options(ps,_,prec,a,Some(Type(_,t)),_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,Some(t),ps);
      n+1
   | SimpleSubpattern(_,_,Options(ps,_,prec,a,Some(EmptyType(_)),_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,None,ps);
      n+1
   | SimpleSubpattern(_,_,Options(ps,_,prec,a,None,_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,Some(get_subpattern_default_type sp),ps);
      n+1
   | RecursiveSubpattern(_,_,_,Options(ps,_,prec,a,Some(Type(_,t)),_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,Some(t),ps);
      n+1
   | RecursiveSubpattern(_,_,_,Options(ps,_,prec,a,Some(EmptyType(_)),_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,None,ps);
      n+1
   | RecursiveSubpattern(_,_,_,Options(ps,_,prec,a,None,_,_,_)) ->
      let x = (get_assoc_str a prec) in
      SubpatternHashtbl.replace h sp (s,x,Some(get_subpattern_default_type sp),ps);
      n+1
;;

let generate_makefile_vars file =
   let olevel = (match !opt_level with
   | None -> ""
   | Some(l) -> " -ccopt -O"^l) in
   let static = (match !compile_static with
   | false -> ""
   | true -> " -ccopt -static") in
   let debug = (match !debug_symbols with
   | false -> ""
   | true -> " -p -g") in
   let (command,xo,xa) = (match !compiler with
   | OCamlC -> ("ocamlc","o","")
   | OCamlOpt -> ("ocamlopt"^olevel^static^debug, "x", "x")
   | OCamlCp -> ("ocamlcp -p a", "o", "")) in
   output_string file ("OCAMLC = "^command^"\n");
   output_string file ("CMO = cm"^xo^"\n");
   output_string file ("CMA = cm"^xa^"a\n");
;;

(* generate Makefile *)
let generate_makefile_code file prefix =
   output_warning_msg file "#\n" "#" "#" "#";
   output_string file "\n\n";
   output_string file "ifndef OCAMLC\n";
   generate_makefile_vars file;
   output_string file "endif\n";
   output_string file (prefix^"main.$(CMO):\t"^prefix^"main.ml "^prefix^"parser.$(CMO) "^prefix^"lexer.$(CMO) "^
                      prefix^"ast.$(CMO) "^prefix^"utils.$(CMO)\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"main.ml\n");
   output_string file ("\n");
   output_string file (""^prefix^"parser.$(CMO):\t"^prefix^"parser.ml "^prefix^"parser.cmi "^
                      prefix^"utils.$(CMO)\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"parser.ml\n");
   output_string file ("\n");
   output_string file (""^prefix^"lexer.$(CMO):\t"^prefix^"lexer.ml "^prefix^"parser.cmi "^
                      prefix^"ast.$(CMO) "^prefix^"utils.$(CMO)\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"lexer.ml\n");
   output_string file ("\n");
   output_string file (""^prefix^"parser.cmi:\t"^prefix^"parser.mli "^prefix^"ast.$(CMO) "^
                      prefix^"utils.$(CMO)\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"parser.mli\n");
   output_string file ("\n");
   output_string file (""^prefix^"ast.$(CMO):\t"^prefix^"ast.ml "^prefix^"utils.$(CMO)\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"ast.ml\n");
   output_string file ("\n");
   output_string file (""^prefix^"parser.ml:\t"^prefix^"parser.mly\n");
   output_string file ("\t\tocamlyacc "^prefix^"parser.mly\n");
   output_string file ("\n");
   output_string file (""^prefix^"parser.mli:\t"^prefix^"parser.mly\n");
   output_string file ("\t\tocamlyacc "^prefix^"parser.mly\n");
   output_string file ("\n");
   output_string file (""^prefix^"lexer.ml:\t"^prefix^"lexer.mll\n");
   output_string file ("\t\tocamllex "^prefix^"lexer.mll\n");
   output_string file ("\n");
   output_string file (""^prefix^"utils.$(CMO):\t"^prefix^"utils.ml\n");
   output_string file ("\t\t$(OCAMLC) -c "^prefix^"utils.ml\n");
   output_string file ("\n");
  output_string file (prefix^"clean:\t\t\t\n");
  output_string file ("\t\t\trm -rf *.cm* *.mli "^prefix^"parser.ml "^prefix^"lexer.ml\n");
;;

(* generate ast.ml *)
let get_str_fun (ty : string) : string option = 
   let t = Str.split (Str.regexp "[\r\n\t ]+") ty in
   let len = List.length t in
   if (len > 0) then (
      let first = 
      (match (List.hd t) with
      | "bool" -> Some("string_of_bool") (* TODO ? *)
      | "char" -> Some("String.make 1")
      | "int" -> Some("string_of_int")
      | "float" -> Some("string_of_float")
      | "int32" -> Some("Int32.to_string")
      | "int64" -> Some("Int64.to_string")
      (* TODO XXX - add the other ones!!! and ones ending in "list" etc *)
      | _ -> None) in
      if (len=1) then first
      else if (len=2) then (  (* && ((List.nth t 1)="list")) then Some("str_list ") *)
         match (first,List.nth t 1) with
         | (Some(s),"list") -> Some("str_list ("^s^")")
         | _ -> None
      ) else None
   ) else None
;;

let rec get_atom_str_helper (a : atom) (append : bool) : string option =
   match a with
   | IdentAtom(_,_) -> None
   | StringAtom(_,s) -> Some(s)
   | CharsetsAtom(_,cs) -> get_charsets_str_helper cs
   | ChoiceAtom(_,s,sl) ->
      List.fold_left (fun r s ->
         match r with
         | Some(_) -> r
         | _ -> get_subpatterns_str_helper s
      ) None (s::sl)
   (*if (is_atom_flat a) then (Some((if append then "^" else "")^"\"FLAT_TODO\"")) else None*)
and get_charsets_str_helper (cs : charsets) : string option =
   match cs with
   | SimpleCharsets(_,c) -> get_charset_str_helper c (ListCharset(NoPos,[],false))
   | DiffCharsets(_,c,not_c) -> get_charset_str_helper c not_c
and get_charset_str_helper (c : charset) (not_c : charset) : string option =
   match (c,not_c) with
   | (WildcardCharset(_),WildcardCharset(_)) -> None
   | (WildcardCharset(_),SingletonCharset(_,c)) -> charop_to_strop (get_unused_char [c])
   | (WildcardCharset(_),ListCharset(_,chl,inv)) ->
      let cl = get_char_list chl in
      if inv then (get_first_strop cl) else charop_to_strop (get_unused_char cl)
   | (SingletonCharset(_,c),WildcardCharset(_)) -> None
   | (SingletonCharset(_,c1),SingletonCharset(_,c2)) -> if (c1=c2) then None else Some(String.make 1 c1)
   | (SingletonCharset(_,c),ListCharset(_,chl,inv)) ->
      let res = Some(String.make 1 c) in
      let cl = get_char_list chl in
      (if (char_list_contains cl c) then (if inv then res else None) else (if inv then None else res))
   | (ListCharset(_,chl,inv),WildcardCharset(_)) -> None
   | (ListCharset(_,chl,inv),SingletonCharset(_,c2)) -> 
      let cl = get_char_list chl in
      let test = (match cl with
      | [] -> false
      | ct::more -> ct=c2) in
      if inv then charop_to_strop (get_unused_char (cl@[c2])) else (if test then
      (if (List.length cl > 1) then Some(String.make 1 (List.nth cl 1)) else None) else get_first_strop cl)
   | (ListCharset(_,chl,inv),ListCharset(_,chl2,inv2)) -> 
      let cl = get_char_list chl in
      let cl2 = get_char_list chl2 in
      if inv then (if inv2 then charop_to_strop (get_diff_char cl2 cl) else 
      charop_to_strop (get_unused_char (cl@cl2)))
      else (if inv2 then charop_to_strop (get_intersect_char cl cl2) else
      charop_to_strop (get_diff_char cl cl2))

and get_subpatterns_str_helper (sp : subpatterns) : string option =
   match sp with
   | Subpatterns(_,s,sl) ->
      List.fold_left (fun r s ->
         match r with
         | None -> None
         | _ -> get_subpattern_str_helper s
      ) (Some("")) (s::sl)
and get_subpattern_str_helper (s : subpattern) : string option =
   match s with
   | SimpleSubpattern(_,a,_) -> get_atom_str_helper a false
   | RecursiveSubpattern(_,s1,s2,_) -> Some(s1^" "^s2)
;;

let get_atom_str (a : atom) (append : bool) : string =
   let so = get_atom_str_helper a append in
   match so with
   | None -> ""
   | Some(s) -> (if append then "^" else "")^"\""^s^"\""
;;

let get_str_code (v1o : string option) (ty : string) (s : subpattern) : string =
   (* TODO - what about operators? *)
   match v1o with
   | None -> "(* NONE => "^ty^" *) "^(
      match s with
      | SimpleSubpattern(_,a,Options(_,_,_,_,_,_,Some(Code(_,s)),_)) ->
         if (is_string_empty s) then "" else "^(let s = "^(get_atom_str a false)^" in ignore s; "^s^")"
      | RecursiveSubpattern(_,s1,s2,Options(_,_,_,_,_,_,Some(Code(_,s)),_)) ->
         if (is_string_empty s) then "" else "^(let s = \""^s1^" "^s2^"\" in ignore s; "^s^")"
      | SimpleSubpattern(_,a,Options(_,_,_,_,_,_,None,_)) -> get_atom_str a true
      | RecursiveSubpattern(_,s1,s2,Options(_,_,_,_,_,_,None,_)) -> "^\""^s1^" "^s2^"\""
   )
   | Some(v1) -> "(* TODO "^v1^" => "^ty^" *)"^(
      let tf = get_str_fun ty in
      match (s,tf) with
      | (SimpleSubpattern(_,a,Options(_,_,_,_,_,_,Some(Code(_,s)),_)),_) ->
         if (is_string_empty s) then "" else "^(let s = "^v1^" in ignore s; "^s^")"
      | (RecursiveSubpattern(_,s1,s2,Options(_,_,_,_,_,_,Some(Code(_,s)),_)),_) ->
         if (is_string_empty s) then "" else "^(let s = "^v1^" in ignore s; "^s^")"
      | (SimpleSubpattern(_,a,Options(_,_,_,_,_,_,None,_)),Some(fn)) -> "^("^fn^" "^v1^")"
      | (SimpleSubpattern(_,a,Options(_,_,_,_,_,_,None,_)),None) -> get_atom_str a true
      | (RecursiveSubpattern(_,s1,s2,Options(_,_,_,_,_,_,None,_)),Some(fn)) -> "^("^fn^" "^v1^")"
      | (RecursiveSubpattern(_,s1,s2,Options(_,_,_,_,_,_,None,_)),None) -> "^\""^s1^" "^s2^"\""
   )
;;

let rec generate_ast_code file prefix g =
  output_warning_msg file "(*\n" " *" " *" " *)";
  output_string file "\n\n";
  output_string file ("open "^prefix^"utils;;\n");
  output_string file "\n(* AST Data Structure *)\n\n";
  match g with Grammar(_,_,_,px,plx) ->
  let pl = px::plx in
  let (_,_,str,strx,stry,strz,strw) = List.fold_left (fun (flag,prev,str,strx,stry,strz,strw) p -> 
    let (num,str2,str3,str4,str5,str6) = (generate_ast_production_code file prefix flag prev p) in
    (true, num, (str^str2), (strx^str3), (stry^str4), (strz^str5), (strw^str6))
  ) (false,0,"","","","","") pl in
  output_string file (str^";;\n");
  output_string file "\n(* AST Pretty-Print Functions *)\n\n";
  output_string file (strx^";;\n\n");
  output_string file (stry^";;\n\n");
  output_string file (strz^";;\n");
  output_string file "\n(* AST Equality Functions *)\n\n";
  output_string file (strw^";;\n");
and generate_ast_production_code file prefix flag2 (prev : int) p : (int * string * string * string * string * string) =
  match p with Production(_,s,px,plx) ->
    let pl = px::plx in
    let len = List.length pl in
    let (_,r,n2,str,strx,stry,strz,strw) = List.fold_left (fun (k,flag,n,str,strx,stry,strz,strw) p ->
      let (flag2,n2,str2,str3,str4,str5,str6) =
         generate_ast_pattern_code file prefix s prev (if len>1 then n else 0) flag p s flag2 in
      (k+1,flag2,n2,str^str2,strx^str3,stry^str4,strz^str5,strw^str6^(if (k=len && n2 > 1) then "\n   | _ -> false" else ""))
      (* (true,n+1) *)
    ) (1,false,1,"","","","","") pl in
    (if r then (n2,(str^"\n"),(strx^"\n"),(stry^"\n"),(strz^"\n"),(strw^"\n")) else (prev,"","","","",""))
and generate_ast_pattern_code file prefix name (prev : int) n flag p s flag2 : (bool * int * string * string * string * string * string) =
  let prefix_str = (if flag then "\n" else "") in
  match p with Pattern(_,slx,labelo,eof,c,_,_) ->
    let (ignore,label) = (match labelo with
    | None -> (false,None)
    | Some(Type(_,l)) -> (false,Some(l))
    | _ -> (true,None)) in
    if (not ignore) then (
       let nm = (match label with
       | None -> (name^(if n > 0 then ("_"^(string_of_int n)) else ""))
       | Some(label) -> label ) in
       let t = (get_production_type s) in
       let (_,str,strx,stry,_,params,params2) = List.fold_left (fun (flag,str,strx,stry,k,params,params2) s -> 
          let tp = (", "^this_var^(string_of_int k)) in
          let tp2 = (", "^this_var2^(string_of_int k)) in
          let (new_param,new_param2,new_k) = (match s with
          | SimpleSubpattern(_,_,Options(_,_,_,_,Some(EmptyType(_)),_,_,_)) -> ("","",k)
          | RecursiveSubpattern(_,_,_,Options(_,_,_,_,Some(EmptyType(_)),_,_,_)) -> ("","",k)
          | _ -> (tp,tp2,k+1)) in
          let (flag2,str2,str3,str4) = generate_ast_subpattern_code file prefix flag k s in
          (flag2,str^str2,strx^"\n      "^str3,(if (str4="") then stry else (stry^"\n      "^str4)),new_k,params^new_param,params2^new_param2)
       ) (true,"","","",0,"","") slx in
       let result =
       ((if (not flag) then ((if flag2 then "\n and" else "type")^" "^t^" =\n") else "")^
       "   | "^
       nm^
       " of "^(get_production_type "Pos")^str) in
       let result2 =
          ((if (not flag) then
          ((if flag2 then "\nand" else "let\nrec")^" str_"^t^" ("^this_var^" : "^t^") : string =\n   match "^
          this_var^" with\n") else "")^
          "   | "^nm^"(p"^params^") -> \"\""^strx
          )in
       let result3 =
          ((if (not flag) then
          ((if flag2 then "\nand" else "let")^" output_"^t^" (out : out_channel) ("^this_var^" : "^t^
          ") : unit =\n"^"   output_string out (str_"^t^" "^this_var^")") else "")
          )in
       let result4 =
          ((if (not flag) then
          ((if flag2 then "\nand" else "let")^" print_"^t^" ("^this_var^" : "^t^
          ") : unit =\n"^"   output_"^t^" stdout "^this_var^"") else "")
          )in
       let result5 =
          ((if (not flag) then
          ((if flag2 then "\nand" else "let\nrec")^" eq_"^t^" ("^this_var^" : "^t^
          ") ("^this_var2^" : "^t^") : bool =\n   match ("^
          this_var^","^this_var2^") with\n") else "")^
          "   | ("^nm^"(_"^params^"),"^nm^"(_"^params2^")) -> true"^stry
          )in
       (true,n+1,prefix_str^result,prefix_str^result2,result3,result4,prefix_str^result5)
    ) else (
       (flag,n,prefix_str,prefix_str,prefix_str,prefix_str,prefix_str)
    )
and generate_ast_subpattern_code (file : out_channel) (prefix : string) (flag : bool) (k : int) (s : subpattern) : (bool*string*string*string) =
  let i = (string_of_int k) in
  let v1 = this_var^i in
  let v2 = this_var2^i in
  let f = (if flag then " * " else "") in
  let the_code = (fun s -> ("&& (let s = "^v1^" in let t = "^v2^" in ignore s; ignore t; "^s^")")) in
  match s with
  | SimpleSubpattern(ps,a,Options(_,o,_,_,None,_,_,eqco)) ->
    let (flg,str,eq_code) = (if (is_subpattern_flat s) then (
       let t = (get_subpattern_default_type s) in
       (true,t,"(eq_base "^v1^" "^v2^")")
    ) else (
       let (str,eq_code) = (generate_ast_atom_code file prefix a o k) in (true,str,eq_code)
    )) in
    let eq_code2 = (match eqco with
    | Some(Code(_,s)) -> if (is_string_empty s) then "" else the_code s
    | _ -> "&& "^eq_code) in
    (flg,(f^str),get_str_code (Some(v1)) str s, eq_code2)
  | SimpleSubpattern(_,a,Options(_,o,_,_,Some(Type(_,t)),_,_,eqco)) ->
    let t2 = (str_remove_from_front t (prefix^"ast.")) in
    let eq_code = (match eqco with
    | None -> "&& (eq_base "^v1^" "^v2^")"
    | Some(Code(_,s)) -> if (is_string_empty s) then "" else the_code s) in
    (true, (f^t2), get_str_code (Some(v1)) t2 s, ""^eq_code^"") (* TODO - remove_from_front works? *)
  | RecursiveSubpattern(_,a1,a2,Options(_,o,_,_,None,_,_,eqco)) ->
    (* TODO - fix the stuff here *)
    let t2 = "string" in
    let eq_code = (match eqco with
    | None -> "&& (eq_base "^v1^" "^v2^")"
    | Some(Code(_,s)) -> if (is_string_empty s) then "" else the_code s) in
    (true, (f^t2), get_str_code (Some(v1)) t2 s, eq_code)
  | RecursiveSubpattern(_,a1,a2,Options(_,o,_,_,Some(Type(_,t)),_,_,eqco)) ->
    let t2 = (str_remove_from_front t (prefix^"ast.")) in
    let eq_code = (match eqco with
    | None -> "&& (eq_base "^v1^" "^v2^")"
    | Some(Code(_,s)) -> if (is_string_empty s) then "" else the_code s) in
    (true,(f^t2),get_str_code (Some(v1)) t2 s, eq_code)
  | _ -> 
     let t = (get_subpattern_default_type s) in
     (flag,"", get_str_code None t s, "")
(* returns (is_ast_type,code) *)
and generate_ast_atom_code file prefix (a : atom) (o : op option) (k : int) : (string * string) =
  let i = (string_of_int k) in
  let v1 = this_var^i in
  let v2 = this_var2^i in
  let (f,eq_code) = (match a with
  | IdentAtom(_,s) ->
     let t = get_production_type s in
     (t, "eq_"^t)
  | StringAtom(ps,st) ->
    (* TODO - will this always be a string? *)
    (get_atom_default_type a, "eq_base")
  | CharsetsAtom(ps,_) ->
    (* TODO - will this always be a string? *)
    (get_atom_default_type a, "eq_base")
  | ChoiceAtom(_,Subpatterns(_,sub,subs),al) -> (* this should never nontrivially happen because of flattening *)
    (get_atom_default_type a, "eq_base")
    (* ("("^
    (let (_,str,strx,stry) = List.fold_left (fun (flag,str,strx,stry) s -> (* TODO - what about strx/y here???!!! *)
      let (flag2,str2,str3,str4) = generate_ast_subpattern_code file prefix flag s in
      (flag2,str^str2,strx^str3,stry^str4)
    ) (false,"","","") (sub::subs) in str)^")") *)
  ) in 
  (* TODO XXX - i think some of this may be unnecessary because the flattening gets rid of all the star/plus/etc ops *)
  (match o with
  | Some(StarOp(_)) -> (f^" list", "(eq_list "^eq_code^" "^v1^" "^v2^")")
  | Some(PlusOp(_)) -> ("("^f^" * "^f^" list)", "(eq_pair "^eq_code^" (eq_list "^eq_code^") "^v1^" "^v2^")")
  | Some(QuestionOp(_)) -> (f^" option", "(eq_option "^eq_code^" "^v1^" "^v2^")")
  | _ -> (f, "("^eq_code^" "^v1^" "^v2^")") )
;;

(* generate parser.mly *)
let generate_parser_code file prefix g (h : ((string*((string*int) option)*string option*pos) SubpatternHashtbl.t)) =
   let toks = ((Hashtbl.create 100) : (string option,string list) Hashtbl.t) in (* type,token_names *)
   let assocs = ((Hashtbl.create 100) : (int,(string*string list)) Hashtbl.t) in (* prec,assoc,token_names *)
   match g with
   | Grammar(p,header,footer,(Production(p2,name,pa,pal) as prodf),prodl) ->
   output_warning_msg file "/*\n(" "*" " *" " *) */";
   output_string file "\n\n";
   output_string file "%{\n";
   output_string file ("   open "^prefix^"ast;;\n");
   output_string file ("   open "^prefix^"utils;;\n");
   output_string file "%}\n\n";
   SubpatternHashtbl.iter (fun k (s,assoc_str,ty,ps) -> 
      let a = (try Hashtbl.find toks ty with _ -> []) in
      Hashtbl.replace toks ty (s::a);
      (match assoc_str with
      | None -> ()
      | Some((asc2,prec2)) ->
         let (asc,sl) = (try Hashtbl.find assocs prec2 with _ -> (asc2,[])) in
         if (asc <> asc2) then die_error ps ("terminal symbol "^s^" cannot have "^
                                                asc2^" assoc at precedence "^(string_of_int prec2));
         Hashtbl.replace assocs prec2 (asc,(s::sl));
      );
   ) h;
   (*let tab2 = List.sort
   (fun (_,p1,_) (_,p2,_) ->
      let i1 = (match p1 with
      | None -> Pervasives.min_int
      | Some(i) -> i) in
      let i2 = (match p2 with
      | None -> Pervasives.min_int
      | Some(i) -> i) in
      compare i1 i2
   ) tab in*)
   (* TODO - sort the following hashtable by the type name *)
   output_string file "%token EOF\n";
   Hashtbl.iter (fun ty sl ->
      let t = (match ty with
      | None -> ""
      | Some(s) -> " <"^s^">") in
      let o = ("%token"^t) in
      let olen = String.length o in
      output_string file o;
      let _ = List.fold_left (fun n s ->
         let x = (" "^s) in 
         let n2 = n+(String.length x) in
         let n3 = if n2 > !page_width then (output_string file "\n"; output_spaces file olen ""; 0) else n2 in
         output_string file x; n3
      ) olen (List.sort (String.compare) sl) in
      output_string file "\n";
   ) toks;
   output_string file "\n";
   let assocl = Hashtbl.fold (fun i (s,sl) res ->
      (i,s,sl)::res
   ) assocs [] in
   (* TODO - add the line wrap for this loop, and sort each list *)
   List.iter (fun (i,s,sl) ->
      output_string file ("%"^s);
      List.iter (fun s ->
         output_string file (" "^s);
      ) sl;
      output_string file (" /* "^(string_of_int i)^" */\n");
   ) (List.sort (fun (i1,_,_) (i2,_,_) -> compare i2 i1) assocl);
   (*List.iter (fun (s,prec,t) ->
      output_string file ("%token "^t^s^" /* "^(match prec with Some(p) -> string_of_int p | _ -> "")^" */\n")
   ) tab2;*)
   output_string file "\n";
   output_string file "%start main /* the entry point */\n";
   output_string file ("%type <"^prefix^"ast."^(get_production_type name)^"> main\n");
   output_string file "%%\n";
   let _ = List.fold_left (fun n ((Production(p2,name,pa,pal)) (*as pr*)) ->
      (* made sure (via parser) that the first production is non-empty *)
      (*if (not (is_production_empty pr)) then begin*)
         let name2 = if n = 1 then "main" else (output_string file "\n"; (get_production_type name)) in
         output_string file (name2^":\n");
         let _ = List.fold_left (fun k (Pattern(_,sl,_,ef,cd,i,asc)) ->
            output_string file "   |";
            let _ = List.fold_left (fun j s ->
               let str = (try let (x,_,_,_) = SubpatternHashtbl.find h s in (" "^x) with _ -> 
                  match s with
                  | SimpleSubpattern(_,IdentAtom(_,name),_) -> (" "^(get_production_type name))
                  | _ -> "XXX" (* TODO - this should never happen - do error? *)
               ) in
               output_string file (str);
               j+1
            ) 1 sl in
            if ef then output_string file " EOF";
            (* TODO - add precedence *)
            output_string file " {";
            (match cd with
            | Code(_,s) -> output_string file s);
            output_string file "}\n";
            k+1
         ) 1 (pa::pal) in 
         output_string file ";\n";
         n+1
      (*end else n*)
   ) 1 (prodf::prodl) in ();
   output_string file "\n";
   output_string file "%%\n";
   output_string file "(* footer code *)\n";
;;

(* generate lexer.mll *)
let rec generate_lexer_code file prefix g (h : (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) =
   output_warning_msg file "(*\n" " *" " *" " *)";
   output_string file "\n\n";
   output_string file "{\n";
   output_string file ("   open "^prefix^"parser;;\n");
   output_string file ("   open "^prefix^"ast;;\n");
   output_string file ("   open "^prefix^"utils;;\n");
   output_string file "}\n\n";
   output_string file ("(* The type \"token\" is defined in "^prefix^"parser.mli *)\n");
   output_string file "rule token = parse\n";
   (* TODO XXX - sort and all that - I THINK THE ORDER NEEDS TO CORRESPOND TO FILE ORDER *)
   let hl = SubpatternHashtbl.fold (fun s (name,assoc_prec,ty,p) res ->
      (name,s,assoc_prec,ty,p)::res
   ) h [] in
   let hl2 = List.sort (fun (name1,_,_,_,_) (name2,_,_,_,_) -> compare name1 name2) hl in
   let tb = "token lexbuf" in
   let rules = List.fold_left (fun rules (name,s,_,ty,p) ->
      let (cd,aft2,tok,rules2) = (match s with
      | SimpleSubpattern(_,_,Options(_,_,_,_,_,cd,_,_)) -> (cd,None,tb,"")
      | RecursiveSubpattern(p,a,b,Options(_,_,_,_,_,cd,_,_)) ->
         let temp = (match cd with
            | Some(Code(_,_) as c) -> if (is_code_empty c) then tb else this_var
            | None -> this_var
         ) in
         let rule_name = ("entry_"^(String.lowercase name)) in
         (cd,Some("let "^this_var^" = "^rule_name^" 0 \"\" lexbuf in"),this_var,
            ("\nand "^rule_name^" n s = parse\n"^
            "| \""^a^"\" { "^rule_name^" (n+1) (s^\""^a^"\") lexbuf }\n"^
            "| \""^b^"\" { if (n=0) then "^temp^" else "^rule_name^" (n-1) (s^\""^b^"\") lexbuf }\n"^
            "| _ as c { if c='\\n' then do_newline lexbuf;\n"^
            "           "^rule_name^" n (Printf.sprintf \"%s%c\" s c) lexbuf }\n")
         )
      ) in
      let (bef,aft) = (match (ty,cd) with (* TODO - bef not used *)
      (* TODO XXX - should <> cause the "token lexbuf" to be generated? *)
      | (None,None) -> ("",name)
      | (None,Some(Code(_,s) as c)) -> ("",if (is_code_empty c) then tok else ("let "^this_var2^" = "^s^" in ignore "^this_var2^"; "^tok))
      | (Some(s),None) -> ("",(name^"("^this_var^")"))
      | (Some(s2),Some(Code(_,s) as c)) ->
         ("",if (is_code_empty c) then tok else ("let "^this_var2^" = "^s^" in ignore "^this_var2^"; "^name^"(t)"
         ))) in
      (match s with
      | SimpleSubpattern(_,IdentAtom(_,_),_) -> ()
      | _ ->
         output_string file "| ";
         let _ = generate_lexer_subpattern_code file s in
         (match aft2 with
         | None -> output_string file (" as "^this_var^" { ignore "^this_var^"; "^aft^" }\n")
         | Some(a) -> output_string file (" { "^a^" ignore "^this_var^"; "^aft^" }\n"))
      );
      (rules^rules2)
   ) "" hl2 in
   output_string file "| eof { EOF }\n";
   output_string file "| _ { lex_error \"lexing error\" lexbuf }\n";
   output_string file rules

and generate_lexer_atom_code file a : bool =
   match a with
   | IdentAtom(ps,s) -> false (* NOTE - this is only used to provide the %prec things to parser.mly,
                               *        so just ignore it*)
   | StringAtom(_,s) -> output_string file ("\""^s^"\""); true
   | CharsetsAtom(_,SimpleCharsets(_,c)) -> generate_lexer_charset_code file c; true
   | CharsetsAtom(_,DiffCharsets(_,c1,c2)) ->
      generate_lexer_charset_code file c1;
      output_string file " # ";
      generate_lexer_charset_code file c2;
      true
   | ChoiceAtom(_,s,sl) ->  (* NOTE - each os the subpattern lists is non-empty *)
      output_string file "(";
      let _ = List.fold_left (fun flag s ->
         if flag then output_string file " | ";
         let _ = generate_lexer_subpatterns_code file s in ();
         true
      ) false (s::sl) in ();
      output_string file ")";
      true

and generate_lexer_subpatterns_code file sp =
   match sp with
   | Subpatterns(_,s,sl) ->
      let (_,res) = List.fold_left (fun (flag,res) s ->
         if flag then output_string file " ";
         let flag2 = generate_lexer_subpattern_code file s in
         (flag2,(res||flag2))
      ) (false,false) (s::sl) in
      res

and generate_lexer_subpattern_code file s : bool =
   (* TODO - what about code subpatterns, i.e. empty patterns *)
   match s with
   | SimpleSubpattern(_,a,Options(_,o,_,_,_,_,_,_)) -> 
      let r = generate_lexer_atom_code file a in
      (match o with
      | Some(StarOp(_)) -> output_string file "*"
      | Some(PlusOp(_)) -> output_string file "+"
      | Some(QuestionOp(_)) -> output_string file "?"
      | _ -> ());
      r
   | RecursiveSubpattern(_,a1,a2,_) -> output_string file ("\""^a1^"\""); true  (* TODO - the rest goes in the semantic rule *)

and generate_lexer_charset_code file c =
   match c with
   | WildcardCharset(_) -> output_string file "_"
   | SingletonCharset(_,c) -> output_string file ("'"^(Char.escaped c)^"'")  (* TODO - escaped!!!! *)
   | ListCharset(_,cl,inv) ->
      output_string file "[";
      let t = (if inv then (output_string file "^"; true) else false) in
      let _ = List.fold_left (fun flag c ->
         if flag then output_string file " ";
         generate_lexer_chars_code file c;
         true
      ) t cl in
      output_string file "]";

and generate_lexer_chars_code file c =
   match c with
   | SingletonChars(_,c) -> output_string file ("'"^(Char.escaped c)^"'") (* TODO - escaped!! *)
   | RangeChars(_,c1,c2) -> 
      output_string file ("'"^(Char.escaped c1)^"'-'"^(Char.escaped c2)^"'")
;;
(* TODO - handle ?,+,* options for the terminals *)

(* TODO - handle the eof.  Also, what is the bool in Options? *)

(* generate main.ml *)
let generate_main_code file prefix g =
   output_warning_msg file "(*\n" " *" " *" " *)" ;
   output_string file "\n\n";
   output_string file ("open "^prefix^"parser;;\n");
   output_string file ("open "^prefix^"lexer;;\n");
   output_string file "\n";
   output_string file "let get_ast (i : in_channel) = \n";
   output_string file ("   "^prefix^"parser.main "^prefix^"lexer.token (Lexing.from_channel i)\n");
   output_string file ";;\n";
;;

(* generate utils.ml *)
let generate_utils_code file g =
   match g with
   | Grammar(p,header,footer,_,_) ->
  output_string file "open Lexing;;\n";
  output_string file "open Parsing;;\n";
  output_string file "(* open Flags;; *)\n";
  output_string file "\n";
  (match header with
  | None -> ()
  | Some(Code(_,s)) -> output_string file (s^"\n"));
  let p = (get_production_type "Pos") in
  output_string file "(* data type for file positions *)\n";
  output_string file ("type "^p^" = NoPos | Pos of string*int*int;; (* file,line,col *)\n");
  output_string file "\n";
  output_string file "exception Parse_error;;\n";
  output_string file "exception Lexing_error;;\n";
  output_string file "\n";
  output_string file "(* do_error p s\n";
  output_string file " *\n";
  output_string file " * Print error message\n";
  output_string file " *\n";
  output_string file " * p - the location of the error\n";
  output_string file " * s - the error message\n";
  output_string file " *\n";
  output_string file " * returns unit\n";
  output_string file " *)\n";
  output_string file ("let do_error (p : "^p^") (s : string) : unit =\n");
  output_string file "   print_string \"Error\";\n";
  output_string file "   print_string (match p with\n";
  output_string file "   | NoPos -> \"\"\n";
  output_string file "   | Pos(file_name,line_num,col_num) -> (\" in '\"^file_name^\n";
  output_string file "    \"' on line \"^(string_of_int line_num)^\" col \"^(string_of_int\n";
  output_string file "    col_num))\n";
  output_string file "   );\n";
  output_string file "   print_string (\": \"^s^\"\\n\")\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file ("let die_error (p : "^p^") (s : string) =\n");
  output_string file "   do_error p s;\n";
  output_string file "   exit 1;\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* dies with a general position-based error *)\n";
  output_string file "let pos_error (s : string) (p : position) = \n";
  output_string file "   let file_name = p.Lexing.pos_fname in\n";
  output_string file "   let line_num  = p.Lexing.pos_lnum  in\n";
  output_string file "   let col_num   = (p.Lexing.pos_cnum-p.Lexing.pos_bol+1) in\n";
  output_string file "   let ps        = Pos(file_name,line_num,col_num) in\n";
  output_string file "   do_error ps s\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* dies with a parse error s *)\n";
  output_string file "let parse_error (s : string) = \n";
  output_string file "   pos_error s (symbol_end_pos ());\n";
  output_string file "   raise Parse_error\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* dies with a lexing error *)\n";
  output_string file "let lex_error (s : string) (lexbuf : Lexing.lexbuf) = \n";
  output_string file "   pos_error s (Lexing.lexeme_end_p lexbuf);\n";
  output_string file "   raise Lexing_error\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* gets a pos data structure using the current lexing pos *)\n";
  output_string file "let get_current_pos () =\n";
  output_string file "   let p         = symbol_start_pos () in\n";
  output_string file "   let file_name = p.Lexing.pos_fname  in\n";
  output_string file "   let line_num  = p.Lexing.pos_lnum   in\n";
  output_string file "   let col_num   = (p.Lexing.pos_cnum-p.Lexing.pos_bol+1) in\n";
  output_string file "   Pos(file_name,line_num,col_num)\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* gets a pos data structure from a lexing position *)\n";
  output_string file "let get_pos (p : Lexing.position) =\n";
  output_string file "   let file_name = p.Lexing.pos_fname in\n";
  output_string file "   let line_num  = p.Lexing.pos_lnum  in\n";
  output_string file "   let col_num   = (p.Lexing.pos_cnum-p.Lexing.pos_bol+1) in\n";
  output_string file "   Pos(file_name,line_num,col_num)\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* updates the lexer position to the next line\n";
  output_string file " * (this is used since we skip newlines in the\n";
  output_string file " *  lexer, but we still wish to remember them\n";
  output_string file " *  for proper line positions) *)\n";
  output_string file "let do_newline lb = \n";
  output_string file "   Lexing.new_line lb\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "(* dies with a system error s *)\n";
  output_string file "let die_system_error (s : string) =\n";
  output_string file "   print_string s;\n";
  output_string file "   print_string \"\\n\";\n";
  output_string file "   exit 1\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "let rec count_newlines s lb = match s with\n";
  output_string file "  | \"\" -> 0\n";
  output_string file "  | _  -> let c = String.sub s 0 1 in\n";
  output_string file "          let cs = String.sub s 1 ((String.length s)-1) in\n";
  output_string file "          if (c=\"\\n\") then (do_newline lb; 1+(count_newlines cs lb))\n";
  output_string file "                      else (count_newlines cs lb)\n";
  output_string file ";;\n";
  output_string file "\n";
  output_string file "let eq_base (a : 'a) (b : 'a) : bool = (a = b) ;;\n";
  output_string file "let eq_pair (f1 : 'a -> 'a -> bool) (f2 : 'b -> 'b -> bool) ((p1a,p1b) : 'a * 'b) ((p2a,p2b) : 'a * 'b) : bool = ((f1 p1a p2a) && (f2 p1b p2b)) ;;\n";
  output_string file "let eq_list (f : 'a -> 'a -> bool) (l1 : 'a list) (l2 : 'a list) : bool = try List.fold_left2 (fun res l1i l2i -> res && (f l1i l2i)) true l1 l2 with _ -> false;;\n";
  output_string file "\n";
  output_string file "let rec str_list (f : 'a -> string) (l : 'a list) : string =\n";
  output_string file "   str_list_helper f l true\n";
  output_string file "\n";
  output_string file "and str_list_helper (f : 'a -> string) (l : 'a list) (first : bool) : string =\n";
  output_string file "   match l with\n";
  output_string file "   | [] -> \"\"\n";
  output_string file "   | a::more -> ((if (not first) then \" \" else \"\")^(f a)^(str_list_helper f more false))\n";
  output_string file ";;\n";
  (match footer with
  | None -> ()
  | Some(Code(_,s)) -> output_string file ("\n"^s));
;;

let generate_skeleton_makefile file prefix =
   let out_file = get_out_file () in
   generate_makefile_vars file;
   output_string file "\n";
   output_string file "LIBS =";
   Hashtbl.iter (fun k v ->
      output_string file (" "^k^".$(CMA)")
   ) libs;
   output_string file "\n\n";
   output_string file (out_file^":\tflags.$(CMO) "^prefix^"utils.$(CMO) "^prefix^"ast.$(CMO) "^
                      prefix^"parser.$(CMO) "^prefix^"lexer.$(CMO) "^prefix^"main.$(CMO) main.$(CMO)\n");
   output_string file ("\t$(OCAMLC) -o "^out_file^" $(LIBS) flags.$(CMO) "^prefix^"utils.$(CMO) "^
                      prefix^"ast.$(CMO) "^prefix^"parser.$(CMO) "^prefix^"lexer.$(CMO) "^
                      prefix^"main.$(CMO) main.$(CMO)\n");
   output_string file "\n";
   output_string file ("main.$(CMO):\tmain.ml "^prefix^"main.$(CMO) "^prefix^"parser.$(CMO) "^
                      prefix^"lexer.$(CMO) "^
                      prefix^"ast.$(CMO) "^prefix^"utils.$(CMO) flags.$(CMO)\n");
   output_string file "\t$(OCAMLC) -c main.ml\n";
   output_string file "\n";
   output_string file "flags.$(CMO):\tflags.ml\n";
   output_string file "\t$(OCAMLC) -c flags.ml\n";
   output_string file "\n";
   output_string file (prefix^"Makefile:\t"^(!filename)^"\n");
   output_string file ("\tpgg "^(!filename)^"\n");
   output_string file "\n";
   output_string file ("clean:\t"^prefix^"clean\n");
   output_string file ("\trm -rf *.o *.cm* *.mli "^prefix^"main.ml "^prefix^"utils.ml "^
                      prefix^"ast.ml "^
                      prefix^"parser.ml "^prefix^"parser.mly "^prefix^"lexer.ml "^
                      prefix^"lexer.mll "^prefix^"Makefile\n");
   output_string file "\n";
   output_string file ("include "^(get_prefix ())^"Makefile\n")
;;

let generate_skeleton_main file prefix =
   let import = String.capitalize prefix in
   output_string file ("open "^import^"main;;\n");
   output_string file ("open Flags;;\n");
   output_string file "\n";
   output_string file "let i = parse_command_line () in\n";
   output_string file "let result = get_ast i in\n";
   output_string file "(* Ast.print_grammar 0 result;\n";
   output_string file "print_newline(); *)\n";
   output_string file "exit 0;;\n";
;;

let generate_skeleton_flags file prefix =
   let out_file = get_out_file () in
   output_string file "(* flag defaults *)\n";
   output_string file "let filename = ref \"\";; (* TODO - this will always be set *)\n";
   output_string file "let out_file = ref (None : string option)\n";
   output_string file "\n";
   output_string file ("let banner_text = \"Welcome to "^out_file^" v. 1.0\";;\n");
   output_string file "let usage_msg = banner_text^\"\\n\"^\n";
   output_string file ("                \"Usage: "^out_file^" [options] <file>\";;\n");
   output_string file "\n";
   output_string file "(* parse the command-line arguments *)\n";
   output_string file "let args = Arg.align [\n";
   output_string file "   (\"-o\",        Arg.String(fun x -> out_file := Some(x)),\n";
   output_string file "                    \"<file> Location for the result\");\n";
   output_string file "];;\n";
   output_string file "\n";
   output_string file "let error_usage_msg () =\n";
   output_string file "   Arg.usage args usage_msg;\n";
   output_string file "   exit 1\n";
   output_string file ";;\n";
   output_string file "\n";
   output_string file "(* dies with a system error s *)\n";
   output_string file "let die_system_error (s : string) =\n";
   output_string file "   print_string s;\n";
   output_string file "   print_string \"\\n\";\n";
   output_string file "   exit 1\n";
   output_string file ";;\n";
   output_string file "\n";
   output_string file "let parse_command_line () : in_channel =\n";
   output_string file "   let f_set = ref false in\n";
   output_string file "   Arg.parse args (fun x -> f_set := true; filename := x) banner_text;\n";
   output_string file "   (* use the command-line filename if one exists, otherwise use stdin *)\n";
   output_string file "   match !f_set with\n";
   output_string file "   | false -> error_usage_msg ()\n";
   output_string file "   | true -> (\n";
   output_string file "      try (open_in !filename)\n";
   output_string file "      with _ -> die_system_error (\"can't read from file: \"^(!filename))\n";
   output_string file "   )\n";
   output_string file ";;\n";
;;

let generate_skeleton () =
   let prefix = get_prefix () in
   let dir = (!out_dir)^(Filename.dir_sep) in
   let makefile_path = dir^"Makefile" in
   if not (Sys.file_exists makefile_path) then (
      let file = create_file makefile_path in
      generate_skeleton_makefile file prefix;
      close_out file
   );
   let main_path = dir^"main.ml" in
   if not (Sys.file_exists main_path) then (
      let file = create_file main_path in
      generate_skeleton_main file prefix;
      close_out file
   );
   let flags_path = dir^"flags.ml" in
   if not (Sys.file_exists flags_path) then (
      let file = create_file flags_path in
      generate_skeleton_flags file prefix;
      close_out file
   );
;;

(*
 * generate_code filename g
 *
 * Generates the OCaml source code for parsing the grammar
 * represented by the specified AST.
 *
 * filename          the filename of the grammar file
 * g2                the AST representing the grammar
 *)
let generate_code (*filename*) g2 =
  (*let name   = get_filename !filename in*)
  let prefix = get_prefix () in
  let prefix_up = String.capitalize prefix in
  let dir    = (!out_dir)^(Filename.dir_sep) in
  let g = flatten_grammar g2 in
  (try Unix.mkdir dir 0o755 with _ -> ());
  match g with
  | Grammar(_, c1, c2, px, plx) ->
    let file_make   = create_file (dir^prefix^"Makefile"  ) in
    (* write the Makefile contents *)
    generate_makefile_code file_make prefix;
    close_out file_make;
    (* TODO - these prints are only in verbose mode! *)
    print_string "done.\n";
    let file_ast    = create_file (dir^prefix^"ast.ml"    ) in
    (* write the ast.ml contents *)
    generate_ast_code file_ast prefix_up g;
    close_out file_ast;
    print_string "done.\n";
    let file_utils  = create_file (dir^prefix^"utils.ml"  ) in
    (* write the utils.ml contents *)
    generate_utils_code file_utils g;
    close_out file_utils;
    print_string "done.\n";
    let h = ((SubpatternHashtbl.create 100) :
       (string*((string*int) option)*string option*pos) SubpatternHashtbl.t) in (* TODO - size? *)
    get_terminals_grammar g h;
    let file_parser = create_file (dir^prefix^"parser.mly") in
    (* write the parser.mly contents *)
    generate_parser_code file_parser prefix_up g h;
    close_out file_parser;
    print_string "done.\n";
    let file_lexer  = create_file (dir^prefix^"lexer.mll" ) in
    (* write the lexer.mll contents *)
    generate_lexer_code file_lexer prefix_up g h;
    close_out file_lexer;
    print_string "done.\n";
    let file_main   = create_file (dir^prefix^"main.ml"   ) in
    (* write the main.ml contents *)
    generate_main_code file_main prefix_up g;
    close_out file_main;
    print_string "done.\n"
;;
