/* parser Test =
| "one" : string
| Two : string
| "three" : string
;

parser Two : int =
| 's' #:int
| 't' #:int
;

parser Three: int =
| 's'
| 't'
;

parser Four: int =
| 's':int # :(_ of int)
| 't':int # :(Bar of int)
| 't':int # :(Foo of int)
;

parser Five: (int*char) =
| 's':int 'z' # :(_ of int*char)
| 't':int 'y' # :(Bar of int*char)
| 't':int 'x' # :(Foo of int*char)
;

parser Six :(string*char) =
| 's':int 'z'
| 't':int 'y'
| 't':int 'x'
;

parser Seven = "one" Seven0:(int*int) "three" ;
parser Seven0 = "two" "four" # :(string*string) ;
*/

/*
parser Eight: (int*char) =
| Eight0 # Zap
| 't':int 'y' # :(Bar of int*char)
| 't':int 'x' # :(Foo of int*char)
;
parser Eight0 :(int*char) = 's' 'z' ;*/

/*parser Expr :int =
| Int
| Expr '+' Expr # {$1 + $2}
| '(':~ Expr ')':~                 // TODO XXX - the ')' should become lexer rules
//| "let" Var '=' Expr "in" Expr
;

lexer Int :int = [0-9]+ ;
lexer Var = [a-zA-Z]+ ;*/

/*parser Test :(int*char) =
| 'a':string 'b':string # :(string*string)
//| 'a' 'b'
//| "str":string "str2":string
;*/

ast Test =
| ~:string ~:string ~:foobar
| Foo "123":int
| "string" * # :(string list)
| "one" (ast Three = "four") "two"
//| 'a' 'b'
//| "str":string "str2":string
;


parser Foo = "one"@prec:=1 | 'c' | Nothing ;

ast Nothing :int = ~ ;
ast Noth_ing :int = ~ ;

parser theAXTest = (parser Inner @two:=123 @three:="abc" = "test")@two:=12345:~ Nothing@prec:=123{n}:~ "one" # :(Foobar of string) | Wow [123]@prec:=1234 | "one"@prec:=0 Test # Foobar ;

lexer Wow3 @prec:=140  = 'c' 'a' 't' ;
lexer Wow @prec:=13  = 'c' 'a' 't' ;

lexer Wow2 @prec:=14  = 'c' 'a' 't' ;

lexer MyTest :token = "c" ;

token MyToken Other :int ;
keyword MyToken = "foobar" ;
parser TheParser = "one" ;


//parser Two:xOne_t = One ;
//parser One = Two ;

// TODO: collect the auto-generated names when unifying (_ of ...)
// TODO: hash all lexer tokens
// TODO: deal with the upper/lowercase idents issues
