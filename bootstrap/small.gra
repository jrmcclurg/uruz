/*property default_production_type = "parser" ;

lexer Outer = ("one" | "two" | ("three" | "four")) | "end" ;
lexer Three : string @$foo = "one" | ("three" | '1' | "four");

parser FooBar @$foo = "one" | (parser MyParser = "three" | ("four")) | "two" (parser Other = "one")+ :int*:string | ("baz") ;

code foo = str{foo} {int_of_string s} eq{=} ;
property parser_code = {one} str{(*this is a test*)} ;

parser Lang :int =
| GetInt '+' GetInt { $1 + $3 }
| GetInt '-' GetInt { $1 - $3 }
;

parser GetInt :int =
| "one" { 1 }
| "two" { 2 }
;

parser Four :int =
| |
| eof { 1 }
| one two eof {12 }
| :int {two} :string :one one {test} :int one
| (<Two:int> two)
| (<Two1:int> = two)
| (parser Two2:int = two)
;

lex one = "one" ;
lex two = "two" ;

keyword Foo = "test" ;*/

//parser TheTest = "one":string @$foo "two"* "three"? "four":int+* {one} {two} @{code} (parser = "test" | ("two" | "three")):foo;
//parser {code} = {code} "foobar" .. '\063' "":int ~:~ | {code2} Brackets;
//parser Brackets = [^^-^a-zA-Z0-9^-s] ;

//code foo = {test} str{code} ;


//lexer Outer = ("one" | "two" | ("three" | "four")) | "end" | 'a' | [1-2a-z];
//lexer Small = "one" ;
//lexer Small2 = "o" ;
//lexer Small3 = 'o' ;

//lexer Small =  ;
//ast TheTests = 'x' '\r' "one\n"* (parser Foo @$foo = "two" | ("three" | "four" @str{test}))+*{do}:(something list)?*+{x}+{one}:int?:int;
//parser TheTest :int = "one" :string {} @$foo : int :string @eq{} @str{} {} :final  ; // TODO XXX - this is a bug
parser TheTest {one} {two} @eq{the1} {three} @str{s1} @eq{the2} :string = "one" : string {this is code} @eq{one} @eq{two} :foobar ;
code foo = str{test};
parser Four = "one" @assoc:="left" | "two" @eq:=str{one} @prec:=123 @color:="#123456" ;
//parser TheTest3 = || "one" | "two" ||| "three" | | | | ~ ;
