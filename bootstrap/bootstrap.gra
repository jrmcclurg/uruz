// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings
// when (AnnotAtom+ "eof"? | '.') is compiled, there are problems when "eof" exists in input
// for ("token" | "tok") within a production, the strings are not pulled out, so it clashes with another "token"
//   in another production

// This is a comment
/*
  This is a multi-line comment
*/

{
   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = ""
   let eq_code a b = false

   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar -> CodeBlock<:(code option)> SemiProd+ CodeBlock<:(code option)> ;
CodeBlock -> 
               : { None }
| CodeLit<:code> : { Some($1) }
;

Production -> ("def" XIdent Opt* '=' | '<' XIdent Opt* '>' EqOp)? Pattern ('|' Pattern)* ;
SemiProd -> (
  Production
| (TokenKw | "tok") XIdent+
| ("keyword" | "kw") XIdent '=' StringQuot
| ("property" | "prop") XIdent+ '=' (Bool<:bool> | Int<:int> | StringQuot)
) ';' ; 
EqOp -> | '=' ;

Pattern -> AnnotAtom+ EofOp ;
EofOp ->
| "eof" ;

Assoc ->
  "left"  : LeftAssoc
| "right" : RightAssoc
| "unary" : UnaryAssoc
;

AnnotAtom ->
  Atom
| AnnotAtom OpOpr
| AnnotAtom Opt
;

Opt ->
  ':' RootType  : TypeOption
| Int<:int>      : PrecOption
| Assoc    : AssocOption
| CodeLit<:code>     : CodeOption // TODO XXX
| "str" CodeLit<:code> : PrintOption
| "eq" CodeLit<:code> : EqOption
;

TokenKw -> "token" ;

RootType ->
  SimpleType
//| '(' ComplexType ')'
| '(' Typ ')'
;

Typ ->
  RootType
| ComplexType
;

SimpleType ->
  TokenKw                        : TokenType // TODO XXX - maybe there's a need to set the name of this type?
| '_'                            : AnyType
| '~'                            : NoType
| '(' ')'                        : UnitType
| TypeName                       : IdentType
;

ComplexType ->
  RootType StarTypList                     : TupleType
| RootType CommaTypList                    : CommaType
| RootType TypeName                        : ConstrType
| (XIdent | '_') "of" Typ : AbstrType
;

TypeName -> XIdent ('.' XIdent)* ;

StarTypList -> ('*' RootType)+ ;
CommaTypList -> (',' RootType)+ ;

OpOpr ->
  '*' : StarOp
| '+' : PlusOp
| '?' : QuestionOp
;

Quot ->
  CharQuot
| StringQuot ;

Atom ->
  '~'        : EmptyAtom // TODO XXX - empty string "" can also denote an empty atom
| StringQuot : StringAtom
| XIdent     : IdentAtom
| Charsets   : CharsetsAtom
| Quot ".." Quot : RecursiveSubpattern
| '(' Production ')'
;

Charsets -> Charset ('/' Charset)? ;

Charset ->
  '_'      : WildcardCharset
| CharQuot : SingletonCharset
| Chars    : ListCharset
;

Bool -> "true" { true } | "false" { false } ;
XIdent -> ([a-zA-Z] [a-zA-Z0-9_]*) ; // TODO XXX - make sure this works with the ident translator
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']') ;
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"') ;
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'') ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeLit -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

{
   (* this is the trailer *)
   let foobar = 1234;;
}
