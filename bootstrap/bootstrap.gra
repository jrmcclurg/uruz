// This is a comment
/*
  This is a multi-line comment
*/

{
   let add_ints a b = a + b;;
   let test_cmp a b = match (a,b) with
     | (x,y) -> x = y
   ;;
}

Grammar -> CodeBlock Production+ CodeBlock eof { Grammar(get_current_pos (),$1,$2,$3) };

CodeBlock ->                            : NoCode    { NoCode(get_current_pos ()) }
           | ('{' [ \n\r\t]* '}') <:()> : EmptyCode { EmptyCode(get_current_pos ()) }
           | '{' .. '}' <@{"'"^s^"'"}>  : Code      { Code(get_current_pos (),$1) } ;

Production -> Pattern 
              ("&" Pattern)*
              CodeBlock ';' <:()> { Production(get_current_pos (),$1,$2,$3) } ;

Pattern -> "hello" <:()> { Pattern(get_current_pos ()) } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};  /* throw away recursive multiline comments */

Blanks -> [\r\n\t ]* <{}:()> : {};

/* Program   ->   "mod" <:() @{s^" "}> Integer <:int>
               "begin" <:() @{"\n"^s}>
               Statement* <:(int list) @{List.fold_left (fun res i -> res^"\n"^(string_of_int i)) "" s}>
               "end" <:() @{"\n"^s}> eof
	       { Program(NoPos,$2,List.map (fun i -> i mod $2) $4) } ;

Statement -> Expr <:int> ';' <:()@{}> { $1 } ;

Expr      -> Integer <:int>                         : IntExpr  { $1 }
           | Expr <:int> "+" <:() left> Expr <:int> : PlusExpr { add_ints $1 $3 } ;

Integer -> ('0' | [1-9] [0-9]*) <{int_of_string s}:int> { $1 } ;*/


/*TestThing -> "one" ;
TestThing2 -> "two" * ;
TestThing3 -> TestThing4 + ;
TestThing4 -> "four" ? ;*/

{
   (* this is the trailer *)
}
