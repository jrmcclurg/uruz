// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings
// when (AnnotAtom+ "eof"? | '.') is compiled, there are problems when "eof" exists in input
// for ("token" | "tok") within a production, the strings are not pulled out, so it clashes with another "token"
//   in another production

// This is a comment
/*
  This is a multi-line comment
*/

{
   type rule_type = Parser | Lexer | Ast
   let eq_rule_type a b = ((compare a b)=0)
   let str_rule_type s = match s with
   | Parser -> "parser"
   | Lexer -> "lexer"
   | Ast -> "ast"
   let str_to_rule_type p s = match s with
   | "parser" | "parse" -> Parser
   | "lexer" | "lex" -> Lexer
   | "ast" -> Ast
   | _ -> die_error p ("production type '"^s^"' does not exist")

   (* TODO XXX - does this need pos information? *)
   type chars = SingletonChar of char | RangeChar of char * char

   (*let str_chars c = match c with SingletonChar(c) -> "{"^(String.make 1 c)^"}" | RangeChar(c1,c2) -> Printf.sprintf "{%c-%c}" c1 c2*)
   let str_chars c = match c with SingletonChar(c) -> String.make 1 c | RangeChar(c1,c2) -> Printf.sprintf "%c-%c" c1 c2
   let eq_chars a b = ((compare a b)=0)

   let rec parse_char_list (cl : char list) : (bool * chars list) = (
  let (is_neg, csl, mode, range_start) = List.fold_left (fun (is_neg, csl, mode, range_start) c ->
    match (c,mode,range_start) with
    | ('^',0,_) -> Printf.printf "x:1\n%!"; (true, csl, 1, None)
    | (_,2,Some(rs)) -> Printf.printf "x:2\n%!"; (is_neg, (RangeChar(rs,c))::csl, 1, None)
    | ('-',_,Some(_)) -> Printf.printf "x:3\n%!"; (is_neg, csl, 2, range_start)
    | (_,_,Some(cx)) -> Printf.printf "x:4\n%!"; (is_neg, (SingletonChar(cx))::csl, 1, Some(c))
    | (_,_,_) -> Printf.printf "x:5\n%!"; (is_neg, csl, 1, Some(c))
  ) (false,[],0,None) cl in
  let extra = (match (range_start,mode) with (Some(c),2) -> ['-';c] | (Some(c),_) -> [c] | _ -> []) in
  let csl = List.rev_append (List.rev_map (fun c -> SingletonChar(c)) extra) csl in
  (is_neg, List.rev csl)
)

   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = match s with EmptyCode(_) -> "" | Code(_,c) -> ("{"^c^"}")
   let eq_code a b = ((compare a b)=0)

  let current_id = ref (-1) ;;
  let symbol_table = ((Hashtbl.create 1000) : (string,int) Hashtbl.t) ;;
  let symbol_table_inv = ((Hashtbl.create 1000) : (int,string) Hashtbl.t) ;;

  let print_symbol_table () =
    Hashtbl.iter (fun k v ->
      print_string ((string_of_int k)^" --> "^v^"\n")
    ) symbol_table_inv

  let force_add_symbol (s : string) (result : int) (complain : bool) : int =
    (*if complain && (try let _ = Hashtbl.find symbol_table s in true with _ -> false) then failwith "multiply-defined symbol";*)
    Hashtbl.replace symbol_table s result;
    Hashtbl.replace symbol_table_inv result s;
    result

  let add_symbol (s : string) : int =
    (try
      int_of_string s
     with _ -> (
     try
      Hashtbl.find symbol_table s
     with _ ->
       let result = !current_id in
       (*print_string (">> ADD SYMBOL: "^s^" = "^(string_of_int result)^"\n");*)
       let _ = force_add_symbol s result false in
       current_id := result - 1;
       result
    ))

  let get_symbol (id : int) : string =
    try Hashtbl.find symbol_table_inv id
    with _ ->
      string_of_int id

  let get_unique_id () : int =
    let result = !current_id in
    current_id := result - 1;
    result

  let string_kw = add_symbol "string"
  let option_kw = add_symbol "option"
  let list_kw = add_symbol "list"

   type symb = int
   let str_symb = get_symbol
   let eq_symb a b = ((compare a b)=0)


   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar ->
  SemiDecl+<:(decl_t*(decl_t list))@{let (x,y)=s in (str_decl_t x)^"\n;"^(str_list (fun y -> "\n\n"^(str_decl_t y)^"\n;") y)}>
;

Production ->
  ProdTypeO<:((rule_type option)*((symb option)*(opt_t list)))
    @{let (x,(y,z))=s in let ystr = (match y with Some(y) -> (get_symbol y) | None -> "_") in match x with
        None -> "<"^ystr^(str_list (fun x -> " "^(str_opt_t x)) z)^"> "
      | Some(x) -> (str_rule_type x)^" "^ystr^(str_list (fun x -> " "^(str_opt_t x)) z)^" = "}>
  BarPattern<:(pattern_t list)
    @{str_list (fun x -> "\n| "^(str_pattern_t x)^"") s}> ;

BarPattern -> BarPattern0<:(pattern_t list)> : { List.rev $1 } ;

ProdType ->
  ProdKw<:rule_type> XIdentO<:(symb option)> OptList<:(opt_t list)> Eq : { (Some($1),($2,$3)) }
| '<'<:()@{"<"}> XIdentO<:(symb option)> OptList<:(opt_t list)> '>'<:()@{">"}> Eq? : { (None,($2,$3)) }
;

ProdTypeO ->
                                                               : { (None,(None,[])) }
| ProdType<:((rule_type option)*((symb option)*(opt_t list)))> : { $1 }
;

XIdentO -> 
                : { None }
| '_'<:()>      : { None }
| XIdent<:symb> : { Some($1) }
;

BarPattern0 ->
  Pattern                : { if (match $1 with Pattern(_,_,[]) -> true | _ -> false) then [] else [$1] }
| BarPattern0 '|' Pattern : { if (match $3 with Pattern(_,_,[]) -> true | _ -> false) then $1 else ($3::$1) }
;

ProdKw -> ("parse" | "parser" | "lex" | "lexer" | "ast")<:string> : { str_to_rule_type (get_current_pos ()) $1 } ;

SemiDecl -> Decl ';' : { $1 } ;

Decl -> 
  Production : ProdDecl
| TokenKws<:()@{"token "}> XIdent+<:(symb*(symb list))> : TokenDecl
| KeywordKws<:()@{"keyword "}> XIdent<:symb> Eq<:()@{" = "}> StringQuot<:string@{Printf.sprintf "%S" s}> : KeywordDecl
| "code"<:()@{"code "}> XIdent<:symb> Eq<:()@{" ="}>
    NamedCode+<:(((symb option)*code)*(((symb option)*code) list))
    @{let (x,y) = s in str_list (fun (so,c) -> " "^(str_option (fun x -> (get_symbol x)^"") so)^(str_code c)) (x::y)}> : CodeDecl
| PropKws<:()@{"property "}> XIdent<:symb> Eq<:()@{" = "}> Value : PropDecl
 ; 

NamedCode ->
  XIdent?<:(symb option)> CodeLit<:code> : { ($1,$2) }
;

TokenKws -> TokenKw<:()> :  | "tok" :  ;
KeywordKws -> "keyword" : | "kw" : ;
PropKws -> "property" : | "prop" : ;

Value ->
  Bool<:bool>         : BoolVal
| Int<:int>           : IntVal
| StringQuot<:string@{Printf.sprintf "%S" s}> : StringVal
| CharQuot<:char@{Printf.sprintf "%C" s}>   : CharVal
|    NamedCode+<:(((symb option)*code)*(((symb option)*code) list))
    @{let (x,y) = s in str_list (fun (so,c) -> " "^(str_option (fun x -> (get_symbol x)^"") so)^(str_code c)) (x::y)}> : CodeVal
;

Eq -> '='<@{" = "}> : ;

Pattern ->
  OptList<:(opt_t list)@{str_list (fun x -> (str_opt_t x)^" ") s}>
  AnnotAtom* <@{str_list (fun x -> (str_annot_atom_t x)^" ") s}>
  //EofOp<:bool@{if s then "eof" else ""}>
;
/*EofOp ->
        : { false }
| "eof" : { true}
;*/

Assoc ->
  "left"<:()>     : LeftAssoc
| "right"<:()>    : RightAssoc
| "nonassoc"<:()> : NonAssoc
;

AnnotAtom ->
  Atom                                : SingletonAnnotAtom
| AnnotAtom Quant                     : QuantAnnotAtom
| AnnotAtom Opt<@{" "^(str_opt_t s)}> : OptAnnotAtom
;

OptList -> Opt*<:(opt_t list)> : { $1 } ;

Opt ->
  ':'<:()> Typ                            : TypeOption
| Int<:int>                               : PrecOption
| Assoc                                   : AssocOption
| FnName<:(symb option)> CodeLit<:code> : CodeOption
| '@'<:()> '$'<:()> XIdent<:symb>       : CodeNameOption
;

FnName -> 
                                   : { None }
| '@'<:()> XIdent?<:(symb option)> : { $2 }
;

TokenKw -> "token" : ;

Typ ->
  SimpleType          : SimpleType
| '('<:()> CompoundType ')'<:()> : CompoundType
;

SimpleType ->
  TokenKw<:()> : TokenType // TODO XXX - maybe there's a need to set the name of this type?
| '_'<:()>      : AnyType
| '~'<:()>      : NoType
| '('<:()> ')'<:()>  : UnitType
| TypeName<:(symb list)@{""^(str_x_list get_symbol s ".")^""}> : IdentType
;

CompoundType ->
  CompoundType1<:((constr_type_t list) list)@{""^(str_x_list (fun x -> str_x_list str_constr_type_t x "*") s ",")^""}> : CommaType
| AbstrName "of"<@{" of "}> TupleType<:(constr_type_t list)@{str_x_list str_constr_type_t s "*"}>   : AbstrType
;

AbstrName ->
  XIdent<:symb> : IdentName
| '_'<:()>        : AnyName
;

CompoundType1 -> CompoundType0<:((constr_type_t list) list)> : { List.rev $1 } ;
CompoundType0 ->
  TupleType<:(constr_type_t list)>                        : { [$1] }
| CompoundType0 ','<:()> TupleType<:(constr_type_t list)> : { $3::$1 }
;

TupleType -> TupleType0<:(constr_type_t list)> : { List.rev $1 } ;
TupleType0 ->
  ConstrType                     : { [$1] }
| TupleType0 '*'<:()> ConstrType : { $3::$1 }
;

ConstrType ->
  Typ                                                                      : SingletonConstrType
| ConstrType TypeName<:(symb list)@{" "^(str_x_list get_symbol s ".")^""}> : InstConstrType
;

TypeName -> TypeName0<:(symb list)> : { List.rev $1 } ;
TypeName0 ->
  XIdent<:symb>               : { [$1] }
| TypeName0 '.' XIdent<:symb> : { $3::$1 } ;

Quant ->
  '*'<:()> : StarQuant
| '+'<:()> : PlusQuant
| '?'<:()> : QuestionQuant
;

Quot ->
  CharQuot<:char>   : { String.make 1 $1 }
| StringQuot<:string> : { $1 }
;

Atom ->
  '~'<:()>                         : EmptyAtom
| "eof"<:()>                       : EofAtom
| StringQuot<:string@{Printf.sprintf "%S" s}>              : StringAtom { let p = get_current_pos () in if String.length $1 > 0 then StringAtom(p, $1) else EmptyAtom(p) }
| XIdent<:symb>                  : IdentAtom
| Charset CharsetDiffOption<:(charset_t option)
    @{str_option (fun x -> " / "^(str_charset_t x)) s}>                         : CharsetAtom
| Quot<:string@{Printf.sprintf "%S" s}> ".."<:()@{" .. "}> Quot<:string@{Printf.sprintf "%S" s}> : RecurAtom
| '('<:()> Production ')'<:()>     : ProdAtom
;

CharsetDiffOption ->
              : { None }
| '/' Charset : { Some($2) }
;

Charset ->
  '_'<:()>               : WildcardCharset
| CharQuot<:char@{Printf.sprintf "%C" s}> : SingletonCharset
| Chars0<:(bool*(chars list))
  @{let (is_neg,cl)=s in Printf.sprintf "[%s%s]" (if is_neg then "^" else "") (str_list str_chars cl)}>    : ListCharset
;

Chars0 -> Chars<:string> : {
  let ib = Scanf.Scanning.from_string ("\""^(String.sub $1 1 ((String.length $1)-2))^"\"") in
  let cl = string_explode (Scanf.bscanf ib "%S" (fun x -> x)) in
  parse_char_list cl
} ;

Bool -> "true" : { true } | "false" : { false } ;
XIdent -> ([a-zA-Z] [a-zA-Z0-9_]*)<:string> : { add_symbol $1 } ; // TODO XXX - make sure this works with the ident translator
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']')<:string> : { $1 } ;
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"')<:string> : { Scanf.sscanf $1 "%S" (fun x -> x) };
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'')<:string> : { (Scanf.sscanf $1 "%C" (fun x -> x)) } ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeLit -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

{
   (* this is the trailer *)
}
