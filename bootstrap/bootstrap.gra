// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings
// when (AnnotAtom+ "eof"? | '.') is compiled, there are problems when "eof" exists in input
// for ("token" | "tok") within a production, the strings are not pulled out, so it clashes with another "token"
//   in another production

// This is a comment
/*
  This is a multi-line comment
*/

{
   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = match s with EmptyCode(_) -> "" | Code(_,c) -> ("{"^c^"}")
   let eq_code a b = false

   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar ->
  CodeBlock<:(code option)@{(str_option str_code s)^"\n"}>
  SemiDecl+<:(decl_t*(decl_t list))@{let (x,y)=s in (str_decl_t x)^";"^(str_list (fun y -> "\n\n"^(str_decl_t y)^";") y)}>
  CodeBlock<:(code option)@{"\n"^(str_option str_code s)}>
;
CodeBlock -> 
                 : { None }
| CodeLit<:code> : { Some($1) }
;

Production ->
  ProdType?<:(((string option)*(string*(opt_t list))) option)
    @{str_option (fun s -> let (x,(y,z))=s in match x with
        None -> "<"^y^(str_list (fun x -> " "^(str_opt_t x)) z)^"> "
      | Some(x) -> x^" "^y^(str_list (fun x -> " "^(str_opt_t x)) z)^" = ") s}>
  Pattern<@{"\n"^(str_pattern_t s)^"\n"}> BarPattern<:(pattern_t list)
    @{str_list (fun x -> "| "^(str_pattern_t x)^"\n") s}> ;

ProdType ->
  ProdKw<:string@{s^" "}> XIdent<:string> OptList<:(opt_t list)> Eq : { (Some($1),($2,$3)) }
| '<' XIdent<:string> OptList<:(opt_t list)> '>' Eq? : { (None,($2,$3)) }
;

BarPattern ->
                 : { [] }
| '|' Pattern BarPattern : { $2::$3 }
;

ProdKw -> ("parse" | "parser" | "lex" | "lexer" | "ast")<:string> : { $1 } ;

SemiDecl -> Decl ';' : { $1 } ;

Decl -> 
  Production : ProdDecl
| TokenKws<:()@{"token "}> XIdent+<:(string*(string list))> : TokenDecl
| KeywordKws<:()@{"keyword "}> XIdent<:string> Eq<:()@{" = "}> StringQuot<:string> : KeywordDecl
| "code"<:()@{"code "}> XIdent<:string> Eq<:()@{" = "}> XIdent?<:(string option)> CodeLit<:code> : CodeDecl
| PropKws<:()@{"property "}> XIdent<:string> Eq<:()@{" = "}> Value : PropDecl
 ; 

TokenKws -> TokenKw<:()> :  | "tok" :  ;
KeywordKws -> "keyword" : | "kw" : ;
PropKws -> "property" : | "prop" : ;

Value ->
  Bool<:bool>         : BoolVal
| Int<:int>           : IntVal
| StringQuot<:string> : StringVal
;

Eq -> '='<@{" = "}> : ;

Pattern ->
  AnnotAtom+ <@{let (x,y)=s in (str_annot_atom_t x)^(str_list (fun y -> " "^(str_annot_atom_t y)) y)}>
  EofOp<:bool@{if s then " eof" else ""}>
;
EofOp ->
        : { false }
| "eof" : { true}
;

Assoc ->
  "left"<:()>     : LeftAssoc
| "right"<:()>    : RightAssoc
| "nonassoc"<:()> : NonAssoc
;

AnnotAtom ->
  Atom                                : SingletonAnnotAtom
| AnnotAtom Quant                     : QuantAnnotAtom
| AnnotAtom Opt<@{" "^(str_opt_t s)}> : OptAnnotAtom
;

OptList -> Opt*<:(opt_t list)> : { $1 } ;

Opt ->
  ':'<:()> Typ                            : TypeOption
| Int<:int>                               : PrecOption
| Assoc                                   : AssocOption
| CodeLit<:code>                          : CodeOption
| '@'<:()> XIdent<:string> CodeLit<:code> : FnOption
| '@'<:()> '$'<:()> XIdent<:string>       : FnNameOption
;

TokenKw -> "token" : ;

Typ ->
  SimpleType          : SimpleType
| '('<:()> CompoundType ')'<:()> : CompoundType
;

SimpleType ->
  TokenKw<:()> : TokenType // TODO XXX - maybe there's a need to set the name of this type?
| '_'<:()>      : AnyType
| '~'<:()>      : NoType
| '('<:()> ')'<:()>  : UnitType
| TypeName<:(string list)@{""^(str_x_list (fun x -> x) s ".")^""}> : IdentType
;

CompoundType ->
 TupleType (',' TupleType)*                : CommaType
| (XIdent<:string> | '_'<:()>) "of"<@{" of "}> TupleType : AbstrType
;

TupleType ->
 ConstrType ('*'<:()> ConstrType)*
;

ConstrType ->
  Typ                                             : SingletonConstrType
| ConstrType TypeName<:(string list)@{" "^(str_x_list (fun x -> x) s ".")^""}> : InstConstrType
;

TypeName ->
  XIdent<:string>              : { [$1] }
| XIdent<:string> '.' TypeName : { $1::$3 } ;

Quant ->
  '*'<:()> : StarQuant
| '+'<:()> : PlusQuant
| '?'<:()> : QuestionQuant
;

Quot ->
  CharQuot<:string>   : { $1 }
| StringQuot<:string> : { $1 }
;

Atom ->
  '~'<:()>                         : EmptyAtom // TODO XXX - empty string "" can also denote an empty atom
| StringQuot<:string>              : StringAtom
| XIdent<:string>                  : IdentAtom
| Charsets                         : CharsetsAtom
| Quot<:string> ".."<:()@{" .. "}> Quot<:string> : RecurAtom
| '('<:()> Production ')'<:()>     : ProdAtom
;

Charsets ->
  Charset CharsetDiffOption<:(charset_t option)
    @{str_option (fun x -> " / "^(str_charset_t x)) s}>
;
CharsetDiffOption ->
              : { None }
| '/' Charset : { Some($2) }
;

Charset ->
  '_'<:()>               : WildcardCharset
| CharQuot<:string> : SingletonCharset
| Chars<:string>    : ListCharset
;

Bool -> "true" : { true } | "false" : { false } ;
XIdent -> ([a-zA-Z] [a-zA-Z0-9_]*)<:string> : { $1 } ; // TODO XXX - make sure this works with the ident translator
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']')<:string> : { $1 } ;
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"')<:string> : { $1 };
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'')<:string> : { $1 } ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeLit -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

{
   (* this is the trailer *)
   let foobar = 1234;;
}
