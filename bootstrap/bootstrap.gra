// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings

// This is a comment
/*
  This is a multi-line comment
*/

{
   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = 
   match s with
   | EmptyCode(_) -> "{}"
   | Code(_,s) -> "{"^s^"}"

   let eq_code a b = ((compare a b)=0)

   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar -> CodeBlock<:(code option)> Production+ CodeBlock<:(code option)> ;
CodeBlock -> 
               : { None }
| CodeZ<:code> : { Some($1) }
;

Production -> XIdent<:string> "->"<:()> Pattern BarPattern*<:(pattern_t list){}> ';'<:()> ;
BarPattern -> '|' Pattern : { $2 } ;

Pattern -> SubPattern* EofOp<:bool> Label CodeBlock<:(code option)>  ;
EofOp ->
        : { false }
| "eof" : { true } ;
Label -> 
| ':'<:()> XIdent?<:(string option)@{str_option (fun x -> x) s}> PatternOpt* ;

PatternOpt -> Int<:int> | Assoc ;

Assoc ->
  "left"  : LeftAssoc
| "right" : RightAssoc
| "unary" : UnaryAssoc
;

SubPattern ->
  "token"                : TokenSubpattern
| Atom Options           : SimpleSubpattern
| Quot ".." Quot Options : RecursiveSubpattern
;

Options -> 
  OpOpr? OptList?
;

OptList -> '<' Opt* '>' ;

Opt ->
  Int<:int>      : PrecOption
| Assoc    : AssocOption
| CodeZ<:code>     : CodeOption
| ':' Typ  : TypeOption
| '@' CodeZ<:code> : PrintOption
| '=' CodeZ<:code> : EqOption
;

Typ ->
  "token"                        : TokenType
| '(' ')'                        : UnitType
| TypeName                       : IdentType
| '(' CommaTypList TypeName ')'  : ConstrType
| '(' Typ StarTypList ')'        : TupleType
| '(' Typ ')'              
;

TypeIdent -> ZTypeIdent | XIdent<:string> ;
TypeName -> 
TypeIdent ('.' TypeIdent)*
;

StarTypList -> ('*' Typ)+ ;
CommaTypList -> Typ (',' Typ)* ;

OpOpr ->
  '*' : StarOp
| '+' : PlusOp
| '?' : QuestionOp
;

Quot ->
  CharQuot
| StringQuot ;

Atom ->
  XIdent<:string>     : IdentAtom
| StringQuot : StringAtom
| Charsets   : CharsetsAtom
| Subs       : ChoiceAtom
;

Charsets -> Charset ('/' Charset)? ;
Subs -> '(' SubPatterns ('|' SubPatterns)* ')' ;

SubPatterns -> SubPattern+ ;

Charset ->
  '_'      : WildcardCharset
| CharQuot : SingletonCharset
| Chars    : ListCharset
;

ZTypeIdent -> ([a-zA-Z] [a-zA-Z0-9_]*) ; // TODO XXX - this clashes with XIdent
XIdent -> ([A-Z] [0-9a-zA-Z]*)<:string> : { $1 } ;
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']') ; // TODO XXX
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"') ;
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'') ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeZ -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};



{
   (* this is the trailer *)
   let foobar = 1234;;
}
