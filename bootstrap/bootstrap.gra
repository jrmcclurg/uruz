// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings
// when (AnnotAtom+ "eof"? | '.') is compiled, there are problems when "eof" exists in input
// for ("token" | "tok") within a production, the strings are not pulled out, so it clashes with another "token"
//   in another production

// This is a comment
/*
  This is a multi-line comment
*/

{
   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = match s with EmptyCode(_) -> "" | Code(_,c) -> ("{"^c^"}")
   let eq_code a b = false

   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar ->
  CodeBlock<:(code option)@{(str_option str_code s)^"\n"}>
  SemiProd+<@{let (x,y)=s in (str_semi_prod_t x)^(str_list (fun y -> "\n\n"^(str_semi_prod_t y)) y)}>
  CodeBlock<:(code option)@{"\n"^(str_option str_code s)}>
;
CodeBlock -> 
                 : { None }
| CodeLit<:code> : { Some($1) }
;

Production ->
  (("parse" | "parser" | "lex" | "lexer" | "ast")<@{s^" "}> XIdent<:string> OptList Eq 
   | '<' XIdent<:string> OptList '>' Eq?
  )?
  Pattern<@{"\n"^(str_pattern_t s)^"\n"}> ('|'<@{"| "}> Pattern<@{(str_pattern_t s)^"\n"}>)* ;

SemiProd -> (
  Production
| (TokenKw<@{(str_token_kw_t s)^" "}> | "tok"<@{s^" "}>) XIdent+<:(string*(string list))>
| ("keyword" | "kw")<@{s^" "}> XIdent<:string> Eq StringQuot<:string>
| "code"<@{s^" "}> XIdent<:string> Eq XIdent?<:(string option)> CodeLit<:code>
| ("property" | "prop")<@{s^" "}> XIdent+<:(string*(string list))> Eq (Bool<:bool> | Int<:int> | StringQuot<:string>)
) ';' ; 

Eq -> '='<@{" = "}> ;

Pattern ->
  AnnotAtom+ <@{let (x,y)=s in (str_annot_atom_t x)^(str_list (fun y -> " "^(str_annot_atom_t y)) y)}>
  EofOp
;
EofOp ->
| "eof"<@{" eof"}> ;

Assoc ->
  "left"     : LeftAssoc
| "right"    : RightAssoc
| "nonassoc" : NonAssoc
;

AnnotAtom ->
  Atom
| AnnotAtom OpOpr
| AnnotAtom Opt<@{" "^(str_opt_t s)}>
;

OptList -> Opt*<@{str_list (fun x -> " "^(str_opt_t x)) s}> ;

Opt ->
  ':' Typ                   : TypeOption
| Int<:int>                 : PrecOption
| Assoc                     : AssocOption
| CodeLit<:code>            : CodeOption
| '@' XIdent<:string> CodeLit<:code> : FnOption
| '@' '$' XIdent<:string>            : FnNameOption
;

TokenKw -> "token" ;

Typ ->
  SimpleType
| '(' ComplexType ')'
;

SimpleType ->
  TokenKw  : TokenType // TODO XXX - maybe there's a need to set the name of this type?
| '_'      : AnyType
| '~'      : NoType
| '(' ')'  : UnitType
| TypeName : IdentType
;

ComplexType ->
 TupleType (',' TupleType)*                : CommaType
| (XIdent<:string> | '_') "of"<@{" of "}> TupleType : AbstrType
;

TupleType ->
 ConstrType ('*' ConstrType)*
;

ConstrType ->
  Typ
| ConstrType TypeName<@{" "^(str_type_name_t s)}>
;

TypeName -> XIdent<:string> ('.' XIdent<:string>)* ;

OpOpr ->
  '*' : StarOp
| '+' : PlusOp
| '?' : QuestionOp
;

Quot ->
  CharQuot<:string>   { $1 }
| StringQuot<:string> { $1 }
;

Atom ->
  '~'                              : EmptyAtom // TODO XXX - empty string "" can also denote an empty atom
| StringQuot<:string>              : StringAtom
| XIdent<:string>                           : IdentAtom
| Charsets                         : CharsetsAtom
| Quot<:string> ".." Quot<:string> : RecurAtom
| '(' Production ')'               : ProdAtom
;

Charsets -> Charset ('/' Charset)? ;

Charset ->
  '_'               : WildcardCharset
| CharQuot<:string> : SingletonCharset
| Chars<:string>    : ListCharset
;

Bool -> "true" : { true } | "false" : { false } ;
XIdent -> ([a-zA-Z] [a-zA-Z0-9_]*)<:string> : { $1 } ; // TODO XXX - make sure this works with the ident translator
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']')<:string> : { $1 } ;
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"')<:string> : { $1 };
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'')<:string> { $1 } ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeLit -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

{
   (* this is the trailer *)
   let foobar = 1234;;
}
