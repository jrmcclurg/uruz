// TODO XXX bug list:
// empty grammar (i.e. no root nonterminal) causes compile error
// "eof"? on RHS of a production doesn't work
// when a (...)* is in a list of item separated by bar, it gives compile warnings
// when (AnnotAtom+ "eof"? | '.') is compiled, there are problems when "eof" exists in input
// for ("token" | "tok") within a production, the strings are not pulled out, so it clashes with another "token"
//   in another production

// This is a comment
/*
  This is a multi-line comment
*/

{
   type code = EmptyCode of pos_t (**
           Empty code having given
           position *)
         | Code of pos_t * string (**
            Code block having given
            position, 
            OCaml code *)

   let str_code s = match s with EmptyCode(_) -> "" | Code(_,c) -> ("{"^c^"}")
   let eq_code a b = ((compare a b)=0)

  let current_id = ref (-1) ;;
  let symbol_table = ((Hashtbl.create 1000) : (string,int) Hashtbl.t) ;;
  let symbol_table_inv = ((Hashtbl.create 1000) : (int,string) Hashtbl.t) ;;


  let print_symbol_table () =
    Hashtbl.iter (fun k v ->
      print_string ((string_of_int k)^" --> "^v^"\n")
    ) symbol_table_inv

  let force_add_symbol (s : string) (result : int) (complain : bool) : int =
    (*if complain && (try let _ = Hashtbl.find symbol_table s in true with _ -> false) then failwith "multiply-defined symbol";*)
    Hashtbl.replace symbol_table s result;
    Hashtbl.replace symbol_table_inv result s;
    result

  let add_symbol (s : string) : int =
    (try
      int_of_string s
     with _ -> (
     try
      Hashtbl.find symbol_table s
     with _ ->
       let result = !current_id in
       (*print_string (">> ADD SYMBOL: "^s^" = "^(string_of_int result)^"\n");*)
       let _ = force_add_symbol s result false in
       current_id := result - 1;
       result
    ))

  let get_symbol (id : int) : string =
    try Hashtbl.find symbol_table_inv id
    with _ ->
      string_of_int id

  let get_unique_id () : int =
    let result = !current_id in
    current_id := result - 1;
    result

   type symb = int
   let str_symb = get_symbol
   let eq_symb a b = ((compare a b)=0)


   let is_string_empty (s : string) : bool =
   (*print_string ("is_empty("^s^")=");*)
   let sp = "[\r\n\t ]+" in
   let t = Str.global_replace (Str.regexp sp) "" s in
   let result = (if t = "" then true else false) in
   (*print_string (if result then "yes" else "no");
   print_string "\n";*)
   result
   ;;

   let rec string_explode (s:string) : char list =
   if (String.length s) > 0 then
      (String.get s 0)::(string_explode (String.sub s 1 ((String.length s)-1)))
   else []
   ;;

   let rec string_combine (cl : char list) : string =
   match cl with
   | [] -> ""
   | c::more -> (String.make 1 c)^(string_combine more)
   ;;

   (* strips (recursive) OCaml comments from a string *)
   let rec strip_ocaml_comments (s : string) : string =
   string_combine (strip_ocaml_comments_helper (string_explode s) [] 0)
   
   and strip_ocaml_comments_helper (cl : char list) (unknown : char list) (level : int) : char list =
   match cl with
   | c1::c2::more ->
      if ((c1 = '(') && (c2 = '*')) then strip_ocaml_comments_helper more (unknown @ [c1;c2]) (level+1)
      else if ((c1 = '*') && (c2 = ')')) then strip_ocaml_comments_helper more (if (level=1) then [] else unknown@[c1;c2]) (level-1)
      else if (level > 0) then strip_ocaml_comments_helper (c2::more) (unknown@[c1]) level
      else c1::(strip_ocaml_comments_helper (c2::more) unknown level)
   | [c] -> c::unknown
   | [] -> unknown
   ;;

   let handle_code ((p,s) : (Lexing.position * string)) : code =
      let p2 = get_pos p in
      (if (is_string_empty (strip_ocaml_comments s)) then EmptyCode(p2) else Code(p2, s))
   ;;
}

Grammar ->
  CodeBlock<:(code option)@{(str_option str_code s)^"\n"}>
  SemiDecl+<:(decl_t*(decl_t list))@{let (x,y)=s in (str_decl_t x)^";"^(str_list (fun y -> "\n\n"^(str_decl_t y)^";") y)}>
  CodeBlock<:(code option)@{"\n"^(str_option str_code s)}>
;
CodeBlock -> 
                 : { None }
| CodeLit<:code> : { Some($1) }
;

Production ->
  ProdType?<:(((string option)*(symb*(opt_t list))) option)
    @{str_option (fun s -> let (x,(y,z))=s in match x with
        None -> "<"^(get_symbol y)^(str_list (fun x -> " "^(str_opt_t x)) z)^"> "
      | Some(x) -> x^" "^(get_symbol y)^(str_list (fun x -> " "^(str_opt_t x)) z)^" = ") s}>
  Pattern<@{"\n"^(str_pattern_t s)^"\n"}> BarPattern<:(pattern_t list)
    @{str_list (fun x -> "| "^(str_pattern_t x)^"\n") s}> ;

ProdType ->
  ProdKw<:string@{s^" "}> XIdent<:symb> OptList<:(opt_t list)> Eq : { (Some($1),($2,$3)) }
| '<' XIdent<:symb> OptList<:(opt_t list)> '>' Eq? : { (None,($2,$3)) }
;

BarPattern ->
                 : { [] }
| '|' Pattern BarPattern : { $2::$3 }
;

ProdKw -> ("parse" | "parser" | "lex" | "lexer" | "ast")<:string> : { $1 } ;

SemiDecl -> Decl ';' : { $1 } ;

Decl -> 
  Production : ProdDecl
| TokenKws<:()@{"token "}> XIdent+<:(symb*(symb list))> : TokenDecl
| KeywordKws<:()@{"keyword "}> XIdent<:symb> Eq<:()@{" = "}> StringQuot<:string> : KeywordDecl
| "code"<:()@{"code "}> XIdent<:symb> Eq<:()@{" ="}>
    NamedCode+<:(((symb option)*code)*(((symb option)*code) list))
    @{let (x,y) = s in str_list (fun (so,c) -> " "^(str_option (fun x -> (get_symbol x)^"") so)^(str_code c)) (x::y)}> : CodeDecl
| PropKws<:()@{"property "}> XIdent<:symb> Eq<:()@{" = "}> Value : PropDecl
 ; 

NamedCode ->
  XIdent?<:(symb option)> CodeLit<:code> : { ($1,$2) }
;

TokenKws -> TokenKw<:()> :  | "tok" :  ;
KeywordKws -> "keyword" : | "kw" : ;
PropKws -> "property" : | "prop" : ;

Value ->
  Bool<:bool>         : BoolVal
| Int<:int>           : IntVal
| StringQuot<:string> : StringVal
| CharQuot<:string>   : CharVal
;

Eq -> '='<@{" = "}> : ;

Pattern ->
  AnnotAtom+ <@{let (x,y)=s in (str_annot_atom_t x)^(str_list (fun y -> " "^(str_annot_atom_t y)) y)}>
  EofOp<:bool@{if s then " eof" else ""}>
;
EofOp ->
        : { false }
| "eof" : { true}
;

Assoc ->
  "left"<:()>     : LeftAssoc
| "right"<:()>    : RightAssoc
| "nonassoc"<:()> : NonAssoc
;

AnnotAtom ->
  Atom                                : SingletonAnnotAtom
| AnnotAtom Quant                     : QuantAnnotAtom
| AnnotAtom Opt<@{" "^(str_opt_t s)}> : OptAnnotAtom
;

OptList -> Opt*<:(opt_t list)> : { $1 } ;

Opt ->
  ':'<:()> Typ                            : TypeOption
| Int<:int>                               : PrecOption
| Assoc                                   : AssocOption
| FnName?<:(symb option)> CodeLit<:code> : CodeOption
| '@'<:()> '$'<:()> XIdent<:symb>       : CodeNameOption
;

FnName -> 
  '@'<:()> XIdent<:symb> : { $2 }
;

TokenKw -> "token" : ;

Typ ->
  SimpleType          : SimpleType
| '('<:()> CompoundType ')'<:()> : CompoundType
;

SimpleType ->
  TokenKw<:()> : TokenType // TODO XXX - maybe there's a need to set the name of this type?
| '_'<:()>      : AnyType
| '~'<:()>      : NoType
| '('<:()> ')'<:()>  : UnitType
| TypeName<:(symb list)@{""^(str_x_list get_symbol s ".")^""}> : IdentType
;

CompoundType ->
  CompoundType1<:((constr_type_t list) list)@{""^(str_x_list (fun x -> str_x_list str_constr_type_t x "*") s ",")^""}> : CommaType
| AbstrName "of"<@{" of "}> TupleType<:(constr_type_t list)@{str_x_list str_constr_type_t s "*"}>   : AbstrType
;

AbstrName ->
  XIdent<:symb> : IdentName
| '_'<:()>        : AnyName
;

CompoundType1 ->
  TupleType<:(constr_type_t list)>                        : { [$1] }
| TupleType<:(constr_type_t list)> ','<:()> CompoundType1 : { $1::$3 }
;

TupleType ->
  ConstrType                    : { [$1] }
| ConstrType '*'<:()> TupleType : { $1::$3 }
;

ConstrType ->
  Typ                                             : SingletonConstrType
| ConstrType TypeName<:(symb list)@{" "^(str_x_list get_symbol s ".")^""}> : InstConstrType
;

TypeName ->
  XIdent<:symb>              : { [$1] }
| XIdent<:symb> '.' TypeName : { $1::$3 } ;

Quant ->
  '*'<:()> : StarQuant
| '+'<:()> : PlusQuant
| '?'<:()> : QuestionQuant
;

Quot ->
  CharQuot<:string>   : { $1 }
| StringQuot<:string> : { $1 }
;

Atom ->
  '~'<:()>                         : EmptyAtom // TODO XXX - empty string "" can also denote an empty atom
| StringQuot<:string>              : StringAtom
| XIdent<:symb>                  : IdentAtom
| Charsets                         : CharsetsAtom
| Quot<:string> ".."<:()@{" .. "}> Quot<:string> : RecurAtom
| '('<:()> Production ')'<:()>     : ProdAtom
;

Charsets ->
  Charset CharsetDiffOption<:(charset_t option)
    @{str_option (fun x -> " / "^(str_charset_t x)) s}>
;
CharsetDiffOption ->
              : { None }
| '/' Charset : { Some($2) }
;

Charset ->
  '_'<:()>               : WildcardCharset
| CharQuot<:string> : SingletonCharset
| Chars<:string>    : ListCharset
;

Bool -> "true" : { true } | "false" : { false } ;
XIdent -> ([a-zA-Z] [a-zA-Z0-9_]*)<:string> : { add_symbol $1 } ; // TODO XXX - make sure this works with the ident translator
Chars -> ('[' ([^\\\]]* ('\\' _)*)* ']')<:string> : { $1 } ;
StringQuot -> ('"' (([^\\\"]* ('\\' _)*)*) '"')<:string> : { Scanf.sscanf $1 "%S" (fun x -> x) };
CharQuot -> ('\'' (([^\\\'] |
         ('\\' ('\\'|'"'|'\''|'n'|'r'|'t'|'b')) |
         ('\\' [0-9] [0-9] [0-9]) )) '\'')<:string> : { String.make 1 (Scanf.sscanf $1 "%C" (fun x -> x)) } ;
Int -> ([0-9]+)<:int{int_of_string s}> : { $1 } ;
CodeLit -> "{" .. "}"<:(Lexing.position*string){let p = Lexing.lexeme_start_p lexbuf in (p,s)}> : { handle_code $1 } ;

SingleComm -> ("//" [^\n]*) <{}:()> : {};  /* throw away single-line comments */
MultiComm  -> "/*" .. "*/" <{}:()> : {};
/* ^^ throw away recursive multiline comments */

Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

{
   (* this is the trailer *)
   let foobar = 1234;;
}
