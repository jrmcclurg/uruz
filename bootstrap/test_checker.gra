{
(*module IntSet = Set.Make(
struct
  type t = int
  let compare = (Pervasives.compare : (int -> int -> int))
end);;*)
this is some code
}

property foo = "true" ;
property foo = false ;

keyword MyKeyword = "test" ;

token One Two THree ;

parser Model:int = (<Model> Empty:bool ElementSemi* 
:(element_t list) @str{
  fst (List.fold_left (fun (res,flag) e ->
    (res^(if flag then "\n" else "")^(str_element_t e),true)) ("",false) s)}
eof)
| (<Graph> AKWgraph:() AAYlsquare GraphElement*:(bool*(int list)) AAYrsquare eof) {
   Model(NoPos,true,List.fold_left (fun acc x -> match x with
   (_,[]) -> acc
   | (false,l) -> (
   let (id,label) = List.fold_left (fun (acc1,acc2) (name,v) -> ((if name="id" then Some(v) else acc1),(if name="label" then Some(v) else acc2))) (None,None) l in
   match (id,label) with
   | (Some(id),Some(label)) ->
     NodeElement(get_current_pos (),Node(get_current_pos (),force_add_symbol (str_label label id) (int_of_string id) true,[],[],[],[]))::acc
   | _ -> failwith "malformed node"
   )
   | (true,l) -> (
   let (id,source,target) = List.fold_left (fun (acc1,acc2,acc3) (name,v) -> ((if name="id" then Some(v) else acc1),(if name="source" then Some(v) else acc2),(if name="target" then Some(v) else acc3))) (None,None,None) l in
   match (id,source,target) with
   | (id,Some(src),Some(dst)) ->
     EdgeElement(get_current_pos (),Edge(get_current_pos (),(match id with Some(id) -> add_symbol id | _ -> get_unique_id ()),Some(int_of_string src),[int_of_string dst],[],1.0))::acc
   | _ -> failwith "malformed node"
   )
   ) [] $3)
} ;
parser Empty = "" { false } ;
parser Empty2 = Empty { false } 123 ;

parser ElementSemi = (Element (<OptSemi> ~ | ';')) { $1 };
parser OptSemi =
  ~
| ';'
;


token AKWfinal ; // final
token AKWtrue; // true
token AKWfalse ; // false
token AKWswitch ; // switch
token AKWlink ; // link
token AKWrule ; // rule
token AKWspec ; // spec
token AKWtraffic ; // traffic
token AKWgraph ; // graph
token AKWnode ; // node
token AKWedge ; // edge


<Element> =
   (<NodeElement> = AKWswitch:()@str{"switch "} Node)
 | (<EdgeElement> = AKWlink:()@str{"link "} Edge)
 | (<SpecElement> = AKWspec:()@str{"spec "} Exp)
 | (<TrafficElement> = AKWtraffic:()@str{"traffic "} Traffic)
;

parser GraphElement =
   GraphField { (false,[]) }
 | (AKWnode:() GraphBlock) { (false,$2) }
 | (AKWedge:() GraphBlock) { (true,$2) }
;

parser GraphBlock = (AAYlsquare GraphField* AAYrsquare) { $2 } ;

parser GraphField = (XIdent GraphValue) { (str_xident_t $1,$2) } ;

parser GraphValue =
  IntegerVal:int  { string_of_int $1 }
| FloatVal:float  { string_of_float $1 }
| String:string   { $1 }
;

parser Traffic =
  Names @str{fst (List.fold_left (fun (res,flag) x ->
    (res^(if flag then "" else ", ")^(get_symbol x),false)) ("",true) s)}:(int list)
  ExpListOpt:(exp_t list) @str{" ["^(fst (List.fold_left (fun (res,flag) p ->
    (res^(if flag then ", " else "")^(str_exp_t p),true)) ("",false) s))^"]"}
  FloatValP:float
    ;
parser Node = Name @str{get_symbol s}:int Ports:(int list) @str{" ("^(fst (List.fold_left (fun (res,flag) i ->
    (res^(if flag then ", " else "")^(get_symbol i),true)) ("",false) s))^")"}
  ExpListOpt:(exp_t list) @str{" ["^(fst (List.fold_left (fun (res,flag) p ->
    (res^(if flag then ", " else "")^(str_exp_t p),true)) ("",false) s))^"]"}
  Rules:(edge_t list) @str{" \123"^(fst (List.fold_left (fun (res,flag) i ->
    (res^(if flag then "" else "")^"\n  rule "^(str_edge_t i),true)) ("",false) s))^"\n\125"}
  FinalRules:(edge_t list) @str{" final \123"^(fst (List.fold_left (fun (res,flag) i ->
    (res^(if flag then "" else "")^"\n  rule "^(str_edge_t i),true)) ("",false) s))^"\n\125"}
;
parser Edge =  UniqueId @str{""}:int
  //EdgeConstraint<@{" ["^(string_of_int s)^"] "}:int>
  Name? @str{(match s with None -> "" | Some(s) -> get_symbol s)}:(int option)
  "=>":() @str{" => "} NamesOpt @str{fst (List.fold_left (fun (res,flag) x ->
  (res^(if flag then "" else ", ")^(get_symbol x),false)) ("",true) s)}:(int list)
  ExpList:(exp_t list) @str{" ["^(fst (List.fold_left (fun (res,flag) p ->
    (res^(if flag then ", " else "")^(str_exp_t p),true)) ("",false) s))^"]"}
  FloatValP:float
    ;

parser UniqueId = ~ { get_unique_id () } ;

parser Ports =
   ~                                                  { [] }
 | (AAYlparen:() AAYrparen:())                    { [] }
 | (AAYlparen:() Names:(int list) AAYrparen:()) { $2 }
;

parser FinalRules =
   ~                                  { [] }
 | (AKWfinal:() Rules:(edge_t list))  { $2 }
;

parser Rules =
   ~                              { [] }
 | (AAYlbrack:() Rule*:(edge_t list) AAYrbrack:()) { $2 }
;

parser MyTest = "one" : token;
parser MyTest2 = "foobar" : (string of string * int) ;
parser MyTest3 = "test" : (((int,int*bool) Hashtbl.t) list list list * string) ;
parser MyTest3 = "test" : ((int*int) Hashtbl.t) ;
parser MyTest3 123 = ("test" : ((int,int) Hashtbl.t)):int 124 ;
parser MyTest3 @$foobar = "test" : (_ of int * string) ;
parser MyTest3 = "test" @str{blah} @$foobar : (Foo of ((int) * string)) ;

code foobar = str{this is code} ;

ast MyTest3 1 2 3   4 5 = ~:(Foo of ((int) * string)) | ~:(Bar of int) ;

ast MyTest3 = (<One> MyTest4 MyTest5*) | (<Two> MyTest2) ;

/*
parser Rule ->
  AKWrule<:()@{"rule"}> Edge { $2 }
;

ExpList ->
   AAYlsquare<:()> AAYrsquare<:()>  { [] }
 | AAYlsquare<:()> Exp ComExp* AAYrsquare<:()> { $2::$3 }
;
ExpListOpt ->
                                    { [] }
 | AAYlsquare<:()> AAYrsquare<:()>  { [] }
 | AAYlsquare<:()> Exp ComExp* AAYrsquare<:()> { $2::$3 }
;

ComExp -> ','<:()> Exp { $2 } ;

Prop ->
   Name<@{"("^(get_symbol s)}:int> '='<:()> Name<@{(get_symbol s)^")"}:int>  : EqProp
;

Exp ->
   BoolVal                      : BoolExp
 | Prop                         : PropExp
 | '!'<:()1> Exp                   : NotExp   // highest precedence
 | 'G'<:()2> Exp                   : GExp
 | 'F'<:()2> Exp                   : FExp
 | 'X'<:()2> Exp                   : XExp
 | Exp<@{}> "&"<:()3@{"("^(str_exp_t s0)^" & "^(str_exp_t s1)^")"}> Exp<@{}>     : AndExp
 | Exp<@{}> "|"<:()4@{"("^(str_exp_t s0)^" | "^(str_exp_t s1)^")"}> Exp<@{}>     : OrExp
 | Exp<@{}> "<->"<:()5@{"("^(str_exp_t s0)^" <-> "^(str_exp_t s1)^")"}> Exp<@{}>   : IffExp
 | Exp<@{}> "->"<:()6@{"("^(str_exp_t s0)^" -> "^(str_exp_t s1)^")"}> Exp<@{}>     : IfExp
 | Exp<@{}> 'U'<:()7@{"("^(str_exp_t s0)^" U "^(str_exp_t s1)^")"}> Exp<@{}>       : UExp
 | Exp<@{}> 'V'<:()7@{"("^(str_exp_t s0)^" V "^(str_exp_t s1)^")"}> Exp<@{}>       : RExp    // lowest precedence
 | AAYlparen<:()> Exp AAYrparen<:()>                  : ParenExp
;

Name -> Value { add_symbol (str_value_t $1) } ;
Names -> 
 Value ComVal* { List.map (fun x -> add_symbol (str_value_t x)) ($1::$2) } ;
NamesOpt -> 
                { [] }
| Value ComVal* { List.map (fun x -> add_symbol (str_value_t x)) ($1::$2) } ;

ComVal -> ','<:()> Value { $2 } ;

FloatVal ->
  FloatP { $1 }
| FloatN { $1 }
;

FloatValP ->
          { !Flags.default_edge_weight }
 | IntP   { float $1 }
 | FloatP { $1 }
;

Value -> 
   IntegerVal<:int>  : IntValue
 | XIdent             : IdentValue
;

IntegerVal ->
   UInt32 { $1 }
 | IntN   { $1 }
;

BoolVal ->
   AKWtrue<:()@{"TRUE"}>  : TrueBoolVal
 | AKWfalse<:()@{"FALSE"}> : FalseBoolVal
;

UInt32 ->
   HexInt { $1 }
 | IntP   { $1 }
;

HexInt -> ("0x" [0-9a-fA-F]+)<{int_of_string s}:int> { $1 } ;
IntN -> ('-' [0-9]+)<{int_of_string s}:int> { $1 } ;
IntP -> ([0-9]+)<{int_of_string s}:int> { $1 } ;
FloatP -> ([0-9]+ '.' [0-9]*)<{float_of_string s}:float> { $1 } ;
FloatN -> ('-' [0-9]+ '.' [0-9]*)<{float_of_string s}:float> { $1 } ;
XIdent -> ([a-zA-Z_] [0-9a-zA-Z_]*)<{lookup_token s}:token@{s}> ;
String -> ('"' (('\\' ('\\' | [0-9a-fA-F] [0-9a-fA-F])) | [^\\\"])* '"')<{fst (strip_quotes s)}> { $1 } ;
AAYlbrack -> "{" ;
AAYrbrack -> "}" ;
AAYlsquare -> "[" ;
AAYrsquare -> "]" ;
AAYlparen -> "(" ;
AAYrparen -> ")" ;


Blanks -> [\r\t ]* <{}:()> : {};
Newlines -> '\n' <{do_newline lexbuf}:()> : {};

*/


parser SingleComm = ("//" [^\n]*) {}:() {};  /* throw away single-line comments */
lexer MultiComm  = "/*" .. "*/" {}:() {};
lexer Multi  = "one" | "two" | "three";
"one" | "two" | "three";
/* ^^ throw away recursive multiline comments */

{
let tokens = ((Hashtbl.create 100) : ((string,token) Hashtbl.t)) ;;
}
